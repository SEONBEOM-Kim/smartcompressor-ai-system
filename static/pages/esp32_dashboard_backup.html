<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 ì„¼ì„œ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
        }

        .sensor-selector {
            margin: 20px 0;
            text-align: center;
        }

        .sensor-selector select {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #3498db;
            border-radius: 25px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            outline: none;
        }

        .sensor-selector select:focus {
            border-color: #2980b9;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .data-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .data-controls select, .data-controls input {
            padding: 8px 15px;
            border: 2px solid #3498db;
            border-radius: 20px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            outline: none;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .status-item {
            text-align: center;
        }

        .status-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .status-online { color: #27ae60; }
        .status-offline { color: #e74c3c; }
        .status-warning { color: #f39c12; }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        .compressor-analysis {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .on-off-ratio {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .ratio-item {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            min-width: 120px;
        }

        .ratio-on {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .ratio-off {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
        }

        .ratio-percentage {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .ratio-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .ratio-summary {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .summary-item {
            text-align: center;
            margin: 5px;
        }

        .summary-label {
            display: block;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .summary-value {
            display: block;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }

        /* ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„ ë¶„ì„ ìŠ¤íƒ€ì¼ */
        .correlation-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        /* ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ ìŠ¤íƒ€ì¼ */
        .admin-dashboard {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .admin-dashboard h3 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .trend-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .trend-controls .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .trend-controls .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .trend-controls .btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .trend-charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .trend-charts {
                grid-template-columns: 1fr;
            }
        }

        .trend-insights {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .trend-insights h4 {
            color: white;
            margin-bottom: 15px;
        }

        .insights-container {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
        }

        .insight-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #3498db;
        }

        .insight-item.warning {
            border-left-color: #f39c12;
        }

        .insight-item.danger {
            border-left-color: #e74c3c;
        }

        .insight-item.success {
            border-left-color: #27ae60;
        }

        /* ì´ìƒ ë°ì´í„° ë¶„ì„ ìŠ¤íƒ€ì¼ */
        .anomaly-analysis {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .anomaly-analysis h3 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .anomaly-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .anomaly-controls .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .anomaly-controls .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .anomaly-controls select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .anomaly-controls select option {
            background: #2c3e50;
            color: white;
        }

        .anomaly-list {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-height: 400px;
            overflow-y: auto;
        }

        .anomaly-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #f39c12;
            transition: all 0.3s ease;
        }

        .anomaly-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .anomaly-item.high-db {
            border-left-color: #e74c3c;
        }

        .anomaly-item.temp-anomaly {
            border-left-color: #3498db;
        }

        .anomaly-item.power-anomaly {
            border-left-color: #9b59b6;
        }

        .anomaly-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .anomaly-time {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .anomaly-type {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .anomaly-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .anomaly-detail {
            text-align: center;
        }

        .anomaly-detail-label {
            font-size: 0.8em;
            opacity: 0.8;
            display: block;
        }

        .anomaly-detail-value {
            font-size: 1.1em;
            font-weight: bold;
            display: block;
            margin-top: 2px;
        }

        .correlation-summary {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        /* ê³ ì¥ ê°ì§€ ì‹œìŠ¤í…œ ìŠ¤íƒ€ì¼ */
        .failure-detection {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: 2px solid #e74c3c;
        }

        .failure-detection h3 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .failure-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f39c12;
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: #27ae60;
        }

        .status-dot.failure {
            background: #e74c3c;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .adaptive-threshold {
            text-align: right;
        }

        .threshold-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .threshold-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #f39c12;
        }

        .failure-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .failure-controls .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .failure-controls .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .failure-controls select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .failure-controls select option {
            background: #2c3e50;
            color: white;
        }

        .failure-list {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-height: 400px;
            overflow-y: auto;
        }

        .failure-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #f39c12;
            transition: all 0.3s ease;
        }

        .failure-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .failure-item.compressor-failure {
            border-left-color: #e74c3c;
        }

        .failure-item.motor-failure {
            border-left-color: #3498db;
        }

        .failure-item.bearing-failure {
            border-left-color: #9b59b6;
        }

        .failure-item.electrical-failure {
            border-left-color: #f39c12;
        }

        .failure-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .failure-time {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .failure-type {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .failure-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .failure-detail {
            text-align: center;
        }

        .failure-detail-label {
            font-size: 0.8em;
            opacity: 0.8;
            display: block;
        }

        .failure-detail-value {
            font-size: 1.1em;
            font-weight: bold;
            display: block;
            margin-top: 2px;
        }

        .confidence-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }

        /* ê³ ì¥ ì•Œë¦¼ ìŠ¤íƒ€ì¼ */
        .failure-alert {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(231, 76, 60, 0.3);
            z-index: 10000;
            animation: slideIn 0.5s ease-out;
            max-width: 300px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-content h4 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        .alert-content p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        /* ë§¥ë½ ê¸°ë°˜ í•™ìŠµ ì‹œìŠ¤í…œ ìŠ¤íƒ€ì¼ */
        .contextual-learning {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            border: 2px solid #9b59b6;
        }

        .contextual-learning h3 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .learning-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .learning-progress {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9em;
            font-weight: bold;
        }

        .learning-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group label {
            font-size: 0.9em;
            opacity: 0.9;
            white-space: nowrap;
        }

        .control-group select,
        .control-group input[type="range"] {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 4px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .control-group select option {
            background: #2c3e50;
            color: white;
        }

        .control-group input[type="range"] {
            width: 80px;
        }

        .learning-controls .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .learning-controls .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .learning-controls .btn.primary {
            background: rgba(46, 204, 113, 0.3);
            border-color: rgba(46, 204, 113, 0.5);
        }

        .learning-controls .btn.primary:hover {
            background: rgba(46, 204, 113, 0.5);
        }

        .learning-filters {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .learning-filters select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            min-width: 150px;
        }

        .learning-filters select option {
            background: #2c3e50;
            color: white;
        }

        .learning-results {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-height: 400px;
            overflow-y: auto;
        }

        .learning-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #f39c12;
            transition: all 0.3s ease;
        }

        .learning-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .learning-item.gradual-degradation {
            border-left-color: #e67e22;
        }

        .learning-item.sudden-failure {
            border-left-color: #e74c3c;
        }

        .learning-item.intermittent-failure {
            border-left-color: #3498db;
        }

        .learning-item.cascade-failure {
            border-left-color: #9b59b6;
        }

        .learning-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .learning-time {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .learning-pattern {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .learning-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .learning-detail {
            text-align: center;
        }

        .learning-detail-label {
            font-size: 0.8em;
            opacity: 0.8;
            display: block;
        }

        .learning-detail-value {
            font-size: 1.1em;
            font-weight: bold;
            display: block;
            margin-top: 2px;
        }

        .confidence-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }

        /* í•™ìŠµ í†µê³„ ìŠ¤íƒ€ì¼ */
        .learning-statistics {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .learning-statistics h4 {
            margin: 0 0 15px 0;
            text-align: center;
            color: #f39c12;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .pattern-breakdown,
        .failure-breakdown {
            margin-top: 15px;
        }

        .pattern-breakdown h5,
        .failure-breakdown h5 {
            margin: 0 0 10px 0;
            color: #3498db;
        }

        .pattern-item,
        .failure-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 8px;
            border-left: 3px solid #f39c12;
        }

        .pattern-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
            margin: 5px;
        }

        .stat-label {
            display: block;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .alert {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: bold;
            color: #2c3e50;
        }

        .data-table tr:hover {
            background: #f5f5f5;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 20px;
            }
            
            .controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- í—¤ë” -->
        <div class="header">
            <h1>ğŸ§Š ESP32 ì•„ì´ìŠ¤í¬ë¦¼ ê°€ê²Œ ëª¨ë‹ˆí„°ë§</h1>
            <p>ì‹¤ì‹œê°„ ì••ì¶•ê¸° ìƒíƒœ ë° ì„¼ì„œ ë°ì´í„° ë¶„ì„</p>
            
            <!-- ì„¼ì„œ ì„ íƒ -->
            <div class="sensor-selector">
                <label for="sensorSelect">ì„¼ì„œ ì„ íƒ:</label>
                <select id="sensorSelect" onchange="changeSensor()">
                    <option value="">ì „ì²´ ì„¼ì„œ</option>
                </select>
            </div>
            
            <!-- ë°ì´í„° ì œì–´ -->
            <div class="data-controls">
                <div>
                    <label for="dataLimit">ë°ì´í„° ê°œìˆ˜:</label>
                    <select id="dataLimit" onchange="loadData()">
                        <option value="50">50ê°œ</option>
                        <option value="100" selected>100ê°œ</option>
                        <option value="200">200ê°œ</option>
                    </select>
                </div>
                <div>
                    <label for="timeRange">ì‹œê°„ ë²”ìœ„:</label>
                    <select id="timeRange" onchange="loadData()">
                        <option value="6">ìµœê·¼ 6ì‹œê°„</option>
                        <option value="12">ìµœê·¼ 12ì‹œê°„</option>
                        <option value="24" selected>ìµœê·¼ 24ì‹œê°„</option>
                        <option value="72">ìµœê·¼ 3ì¼</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- ìƒíƒœ ë°” -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-value" id="connectionStatus">ì—°ê²° ì¤‘...</div>
                <div class="status-label">ì—°ê²° ìƒíƒœ</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="deviceCount">0</div>
                <div class="status-label">í™œì„± ë””ë°”ì´ìŠ¤</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="lastUpdate">--:--</div>
                <div class="status-label">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="dataCount">0</div>
                <div class="status-label">ì´ ë°ì´í„° ìˆ˜</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="soundType">-</div>
                <div class="status-label">ì†Œë¦¬ ìœ í˜•</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="intensityLevel">-</div>
                <div class="status-label">ê°•ë„ ë ˆë²¨</div>
            </div>
        </div>

        <!-- ì•Œë¦¼ ì˜ì—­ -->
        <div id="alerts"></div>

        <!-- ì»¨íŠ¸ë¡¤ -->
        <div class="controls">
            <button class="btn btn-primary" onclick="refreshData()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
            <button class="btn btn-success" onclick="startAutoRefresh()">â–¶ï¸ ìë™ ìƒˆë¡œê³ ì¹¨</button>
            <button class="btn btn-warning" onclick="stopAutoRefresh()">â¸ï¸ ìë™ ìƒˆë¡œê³ ì¹¨ ì¤‘ì§€</button>
            <a href="/audio-research" class="btn btn-primary">ğŸµ ì˜¤ë””ì˜¤ ì—°êµ¬</a>
        </div>

        <!-- ë©”ì¸ ê·¸ë¦¬ë“œ -->
        <div class="grid">
            <!-- ì••ì¶•ê¸° ì‘ë™ íŒ¨í„´ ì°¨íŠ¸ -->
            <div class="card">
                <h3>ğŸ“Š ì••ì¶•ê¸° ì‘ë™ íŒ¨í„´ ë¶„ì„</h3>
                <div class="chart-container">
                    <canvas id="compressorChart"></canvas>
                </div>
                <div class="pattern-stats">
                    <div class="stat-item">
                        <span class="stat-label">í‰ê·  ì‘ë™ ì‹œê°„:</span>
                        <span class="stat-value" id="avgOnTime">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">í‰ê·  ëŒ€ê¸° ì‹œê°„:</span>
                        <span class="stat-value" id="avgOffTime">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ì‘ë™ ì£¼ê¸°:</span>
                        <span class="stat-value" id="cycleCount">-</span>
                    </div>
                <div class="stat-item">
                    <span class="stat-label">ì‘ë™ íš¨ìœ¨ì„±:</span>
                    <span class="stat-value" id="efficiency">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">íŒ¨í„´ ì•ˆì •ì„±:</span>
                    <span class="stat-value" id="stability">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">í˜„ì¬ ì˜¨ë„:</span>
                    <span class="stat-value" id="currentTemp">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì˜ˆìƒ ì‘ë™ë¹„ìœ¨:</span>
                    <span class="stat-value" id="expectedRatio">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì˜¨ë„ íš¨ìœ¨ì„±:</span>
                    <span class="stat-value" id="tempEfficiency">-</span>
                </div>
                    <div class="stat-item">
                        <span class="stat-label">íŒ¨í„´ íŠ¸ë Œë“œ:</span>
                        <span class="stat-value" id="patternTrend">-</span>
                    </div>
                </div>
            <div class="chart-container">
                <canvas id="cyclePatternChart"></canvas>
            </div>
        </div>

        <!-- ë§¥ë½ ê¸°ë°˜ ê³ ì¥ ë¼ë²¨ë§ AI í•™ìŠµ -->
        <div class="card contextual-learning">
            <h3>ğŸ§  ë§¥ë½ ê¸°ë°˜ ê³ ì¥ ë¼ë²¨ë§ AI í•™ìŠµ</h3>
            <div class="learning-status">
                <div class="status-indicator">
                    <span class="status-dot" id="learningStatus"></span>
                    <span class="status-text" id="learningStatusText">AI í•™ìŠµ ëŒ€ê¸° ì¤‘...</span>
                </div>
                <div class="learning-progress">
                    <span class="progress-label">í•™ìŠµ ì§„í–‰ë„:</span>
                    <div class="progress-bar">
                        <div class="progress-fill" id="learningProgress" style="width: 0%"></div>
                    </div>
                    <span class="progress-text" id="learningProgressText">0%</span>
                </div>
            </div>
            <div class="learning-controls">
                <div class="control-group">
                    <label>í•™ìŠµ ê¸°ê°„:</label>
                    <select id="learningPeriod">
                        <option value="1">ìµœê·¼ 1ì‹œê°„</option>
                        <option value="6">ìµœê·¼ 6ì‹œê°„</option>
                        <option value="24" selected>ìµœê·¼ 24ì‹œê°„</option>
                        <option value="168">ìµœê·¼ 1ì£¼ì¼</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>ìœˆë„ìš° í¬ê¸°:</label>
                    <select id="windowSize">
                        <option value="60">1ë¶„</option>
                        <option value="300" selected>5ë¶„</option>
                        <option value="900">15ë¶„</option>
                        <option value="3600">1ì‹œê°„</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>ìµœì†Œ ì‹ ë¢°ë„:</label>
                    <input type="range" id="minConfidence" min="0" max="100" value="60" onchange="updateConfidenceDisplay()">
                    <span id="confidenceDisplay">60%</span>
                </div>
                <button class="btn primary" onclick="startContextualLearning()">ì‹¤ì‹œê°„ í•™ìŠµ ì‹œì‘</button>
                <button class="btn" onclick="pauseLearning()">í•™ìŠµ ì¼ì‹œì •ì§€</button>
                <button class="btn" onclick="showLearningResults()">í•™ìŠµ ê²°ê³¼ ì¡°íšŒ</button>
                <button class="btn" onclick="showLearningStatistics()">í•™ìŠµ í†µê³„</button>
                <button class="btn" onclick="exportLearningData()">ë°ì´í„° ë‚´ë³´ë‚´ê¸°</button>
            </div>
            <div class="learning-filters">
                <select id="learningFilter" onchange="filterLearningResults()">
                    <option value="all">ì „ì²´ íŒ¨í„´</option>
                    <option value="gradual_degradation">ì ì§„ì  ì„±ëŠ¥ ì €í•˜</option>
                    <option value="sudden_failure">ê¸‰ê²©í•œ ê³ ì¥</option>
                    <option value="intermittent_failure">ê°„í—ì  ê³ ì¥</option>
                    <option value="cascade_failure">ê³„ë‹¨ì‹ ê³ ì¥</option>
                    <option value="thermal_stress">ì—´ ì‘ë ¥</option>
                    <option value="normal_operation">ì •ìƒ ìš´ì˜</option>
                </select>
                <select id="failureTypeFilter" onchange="filterLearningResults()">
                    <option value="all">ì „ì²´ ê³ ì¥ ìœ í˜•</option>
                    <option value="bearing_wear">ë² ì–´ë§ ë§ˆëª¨</option>
                    <option value="electrical_fault">ì „ê¸° ê³ ì¥</option>
                    <option value="mechanical_looseness">ê¸°ê³„ì  ëŠìŠ¨í•¨</option>
                    <option value="compressor_fatigue">ì••ì¶•ê¸° í”¼ë¡œ</option>
                    <option value="normal">ì •ìƒ</option>
                </select>
            </div>
            <div class="learning-results" id="learningResults">
                <p>ë§¥ë½ ê¸°ë°˜ AI í•™ìŠµì„ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</p>
            </div>
        </div>

        <!-- 24ì‹œê°„ ê³ ì¥ ì‹ í˜¸ ìë™ ê°ì§€ -->
        <div class="card failure-detection">
            <h3>ğŸš¨ 24ì‹œê°„ ê³ ì¥ ì‹ í˜¸ ìë™ ê°ì§€</h3>
            <div class="failure-status">
                <div class="status-indicator" id="failureStatus">
                    <span class="status-dot"></span>
                    <span class="status-text">ëª¨ë‹ˆí„°ë§ ì¤‘...</span>
                </div>
                <div class="adaptive-threshold">
                    <span class="threshold-label">ì ì‘í˜• ì„ê³„ê°’:</span>
                    <span class="threshold-value" id="adaptiveThreshold">45.0 dB</span>
                </div>
            </div>
            <div class="failure-controls">
                <button class="btn" onclick="startFailureMonitoring()">ê³ ì¥ ê°ì§€ ì‹œì‘</button>
                <button class="btn" onclick="showFailureDetails()">ê³ ì¥ ê¸°ë¡ ì¡°íšŒ</button>
                <button class="btn" onclick="exportFailureReport()">ê³ ì¥ ë³´ê³ ì„œ</button>
                <select id="failureFilter" onchange="filterFailures()">
                    <option value="all">ì „ì²´ ê³ ì¥</option>
                    <option value="compressor_failure">ì••ì¶•ê¸° ê³ ì¥</option>
                    <option value="motor_failure">ëª¨í„° ê³ ì¥</option>
                    <option value="bearing_failure">ë² ì–´ë§ ê³ ì¥</option>
                    <option value="electrical_failure">ì „ê¸° ê³ ì¥</option>
                </select>
            </div>
            <div class="failure-list" id="failureList">
                <p>ê³ ì¥ ê°ì§€ë¥¼ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</p>
            </div>
        </div>

        <!-- ì´ìƒ ë°ì´í„° ìƒì„¸ ë¶„ì„ -->
        <div class="card anomaly-analysis">
            <h3>ğŸ“Š ì´ìƒ ë°ì´í„° ìƒì„¸ ë¶„ì„</h3>
            <div class="anomaly-controls">
                <button class="btn" onclick="showAnomalyDetails()">ì´ìƒ ë°ì´í„° ì¡°íšŒ</button>
                <button class="btn" onclick="clearAnomalyDetails()">ëª©ë¡ ì´ˆê¸°í™”</button>
                <select id="anomalyFilter" onchange="filterAnomalies()">
                    <option value="all">ì „ì²´</option>
                    <option value="high_db">ê³ ë°ì‹œë²¨ (â‰¥60dB)</option>
                    <option value="low_temp">ì €ì˜¨ (â‰¤5Â°C)</option>
                    <option value="high_temp">ê³ ì˜¨ (â‰¥25Â°C)</option>
                    <option value="power_anomaly">ì „ë ¥ ì´ìƒ</option>
                </select>
            </div>
            <div class="anomaly-list" id="anomalyList">
                <p>ì´ìƒ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ë ¤ë©´ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</p>
            </div>
        </div>

        <!-- ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„ ë¶„ì„ (ê°„ì†Œí™”) -->
        <div class="card">
            <h3>ğŸŒ¡ï¸ ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„</h3>
            <div class="correlation-summary">
                <div class="stat-item">
                    <span class="stat-label">ìƒê´€ê³„ìˆ˜:</span>
                    <span class="stat-value" id="correlationCoeff">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì˜ˆì¸¡ ì •í™•ë„:</span>
                    <span class="stat-value" id="predictionAccuracy">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì—ë„ˆì§€ íš¨ìœ¨ì„±:</span>
                    <span class="stat-value" id="energyEfficiency">-</span>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="temperatureCorrelationChart"></canvas>
            </div>
        </div>

            <!-- RMS ì—ë„ˆì§€ ì°¨íŠ¸ -->
            <div class="card">
                <h3>ğŸ”Š ì†ŒìŒ ë ˆë²¨ (RMS)</h3>
                <div class="chart-container">
                    <canvas id="rmsChart"></canvas>
                </div>
            </div>

            <!-- ì´ìƒ ì ìˆ˜ ì°¨íŠ¸ -->
            <div class="card">
                <h3>âš ï¸ ì´ìƒ ê°ì§€ ì ìˆ˜</h3>
                <div class="chart-container">
                    <canvas id="anomalyChart"></canvas>
                </div>
            </div>

            <!-- ë°ì‹œë²¨ ë ˆë²¨ ì°¨íŠ¸ -->
            <div class="card">
                <h3>ğŸ”Š ë°ì‹œë²¨ ë ˆë²¨</h3>
                <div class="chart-container">
                    <canvas id="decibelChart"></canvas>
                </div>
            </div>

            <!-- ì••ì¶•ê¸° ìƒíƒœ ë¶„ì„ -->
            <div class="compressor-analysis">
                <h3>ğŸ”§ ì••ì¶•ê¸° ìƒíƒœ ë¶„ì„ (45dB ê¸°ì¤€)</h3>
                <div class="on-off-ratio">
                    <div class="ratio-item ratio-on">
                        <div class="ratio-percentage" id="onPercentage">0%</div>
                        <div class="ratio-label">ON (â‰¥45dB)</div>
                    </div>
                    <div class="ratio-item ratio-off">
                        <div class="ratio-percentage" id="offPercentage">0%</div>
                        <div class="ratio-label">OFF (<45dB)</div>
                    </div>
                </div>
                <div class="ratio-summary">
                    <div class="summary-item">
                        <span class="summary-label">ì´ ì¸¡ì • íšŸìˆ˜:</span>
                        <span class="summary-value" id="totalMeasurements">0</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">ON íšŸìˆ˜:</span>
                        <span class="summary-value" id="onCount">0</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">OFF íšŸìˆ˜:</span>
                        <span class="summary-value" id="offCount">0</span>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="compressorStateChart"></canvas>
                </div>
            </div>

            <!-- ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ -->
            <div class="card">
                <h3>ğŸ“ˆ ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­</h3>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="currentRMS">0</div>
                        <div class="metric-label">RMS ì—ë„ˆì§€</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="currentDecibel">0</div>
                        <div class="metric-label">ë°ì‹œë²¨ (dB)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="currentCompressor">OFF</div>
                        <div class="metric-label">ì••ì¶•ê¸° ìƒíƒœ</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="currentAnomaly">0.0</div>
                        <div class="metric-label">ì´ìƒ ì ìˆ˜</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="currentEfficiency">0.0</div>
                        <div class="metric-label">íš¨ìœ¨ì„±</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="currentSoundType">-</div>
                        <div class="metric-label">ì†Œë¦¬ ìœ í˜•</div>
                    </div>
                </div>
            </div>

            <!-- ìµœê·¼ ë°ì´í„° í…Œì´ë¸” -->
            <div class="card">
                <h3>ğŸ“‹ ìµœê·¼ ì„¼ì„œ ë°ì´í„°</h3>
                <div id="recentData">
                    <div class="loading">
                        <div class="spinner"></div>
                        ë°ì´í„° ë¡œë”© ì¤‘...
                    </div>
                </div>
            </div>
        </div>

        <!-- í‘¸í„° -->
        <div class="footer">
            <p>Smart Compressor AI System - ESP32 ì„¼ì„œ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ</p>
            <p>ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸: <span id="updateTime">--:--:--</span></p>
        </div>
    </div>

    <script>
        // RMSë¥¼ ë°ì‹œë²¨ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
        function rmsToDecibel(rms) {
            if (rms <= 0) return 0;
            // 20 * log10(rms) ê³µì‹ ì‚¬ìš©
            return 20 * Math.log10(rms);
        }

        // ì „ì—­ ë³€ìˆ˜
        let charts = {};
        let autoRefreshInterval = null;
        let dataHistory = {
            timestamps: [],
            compressor: [],
            rms: [],
            anomaly: [],
            decibel: []
        };

        // ì°¨íŠ¸ ì´ˆê¸°í™”
        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'ë°ì´í„° í¬ì¸íŠ¸'
                        }
                    },
                    y: {
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: {
                        display: true
                    }
                }
            };

            // ì••ì¶•ê¸° ìƒíƒœ ì°¨íŠ¸
            charts.compressor = new Chart(document.getElementById('compressorChart'), {
                type: 'line',
                data: {
                    labels: dataHistory.timestamps,
                    datasets: [{
                        label: 'ì••ì¶•ê¸° ìƒíƒœ',
                        data: dataHistory.compressor,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        tension: 0.1
                    }]
                },
                options: chartOptions
            });

            // RMS ì°¨íŠ¸
            charts.rms = new Chart(document.getElementById('rmsChart'), {
                type: 'line',
                data: {
                    labels: dataHistory.timestamps,
                    datasets: [{
                        label: 'RMS ì—ë„ˆì§€',
                        data: dataHistory.rms,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        tension: 0.1
                    }]
                },
                options: chartOptions
            });

            // ì´ìƒ ì ìˆ˜ ì°¨íŠ¸
            charts.anomaly = new Chart(document.getElementById('anomalyChart'), {
                type: 'line',
                data: {
                    labels: dataHistory.timestamps,
                    datasets: [{
                        label: 'ì´ìƒ ì ìˆ˜',
                        data: dataHistory.anomaly,
                        borderColor: '#f39c12',
                        backgroundColor: 'rgba(243, 156, 18, 0.1)',
                        tension: 0.1
                    }]
                },
                options: chartOptions
            });

            // ë°ì‹œë²¨ ì°¨íŠ¸
            charts.decibel = new Chart(document.getElementById('decibelChart'), {
                type: 'line',
                data: {
                    labels: dataHistory.timestamps,
                    datasets: [{
                        label: 'ë°ì‹œë²¨ (dB)',
                        data: dataHistory.decibel,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        tension: 0.1
                    }]
                },
                options: chartOptions
            });
        }

        // ë°ì´í„° ìƒˆë¡œê³ ì¹¨
        async function refreshData() {
            try {
                console.log('[DEBUG] refreshData ì‹œì‘');
                
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                document.getElementById('connectionStatus').textContent = 'ì—°ê²° ì¤‘...';
                document.getElementById('connectionStatus').className = 'status-value status-warning';

                console.log('[DEBUG] API í˜¸ì¶œ ì‹œì‘: /api/sensor/recent');
                
                const sensorId = document.getElementById('sensorSelect').value;
                const limit = document.getElementById('dataLimit').value;
                const hours = document.getElementById('timeRange').value;
                
                let url = `/api/sensor/recent?limit=${limit}&hours=${hours}`;
                if (sensorId) {
                    url += `&device_id=${encodeURIComponent(sensorId)}`;
                }
                
                console.log('[DEBUG] ìš”ì²­ URL:', url);
                
                // ìµœê·¼ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch(url);
                console.log('[DEBUG] API ì‘ë‹µ ìƒíƒœ:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('[ERROR] ì‘ë‹µì´ JSONì´ ì•„ë‹™ë‹ˆë‹¤:', text.substring(0, 200));
                    throw new Error('ì„œë²„ê°€ JSONì´ ì•„ë‹Œ ì‘ë‹µì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.');
                }
                
                const data = await response.json();
                console.log('[DEBUG] API ì‘ë‹µ ë°ì´í„°:', data);

                if (data.success) {
                    console.log('[DEBUG] ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹œì‘, ë°ì´í„° ê°œìˆ˜:', data.data.length);
                    updateDashboard(data.data);
                    document.getElementById('connectionStatus').textContent = 'ì—°ê²°ë¨';
                    document.getElementById('connectionStatus').className = 'status-value status-online';
                    console.log('[DEBUG] ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                } else {
                    throw new Error(data.message || 'ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }

            } catch (error) {
                console.error('[DEBUG] ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                document.getElementById('connectionStatus').textContent = 'ì—°ê²° ì‹¤íŒ¨';
                document.getElementById('connectionStatus').className = 'status-value status-offline';
                showAlert('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: ' + error.message, 'danger');
            }
        }

        // ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
        function updateDashboard(data) {
            if (!data || data.length === 0) {
                showAlert('ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                return;
            }

            // ìµœì‹  ë°ì´í„°ë¡œ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            const latest = data[0];
            const currentDecibel = rmsToDecibel(latest.rms_energy);
            document.getElementById('currentRMS').textContent = latest.rms_energy.toFixed(2);
            document.getElementById('currentDecibel').textContent = currentDecibel.toFixed(1) + ' dB';
            // 45dB ê¸°ì¤€ìœ¼ë¡œ ì••ì¶•ê¸° ìƒíƒœ ê²°ì •
            document.getElementById('currentCompressor').textContent = currentDecibel >= 45 ? 'ON' : 'OFF';
            document.getElementById('currentAnomaly').textContent = latest.anomaly_score.toFixed(3);
            document.getElementById('currentEfficiency').textContent = latest.efficiency_score.toFixed(3);
            
            // ìƒˆë¡œìš´ ê³ ê¸‰ íŠ¹ì§• ì—…ë°ì´íŠ¸
            const soundType = latest.sound_type || 0;
            const soundTypeNames = ['ì •ì ', 'ì••ì¶•ê¸°', 'íŒ¬', 'ì´ìƒìŒ', 'ê¸°íƒ€'];
            const soundTypeName = soundTypeNames[Math.round(soundType)] || 'ì•Œ ìˆ˜ ì—†ìŒ';
            const soundTypeColors = ['#95a5a6', '#e74c3c', '#3498db', '#f39c12', '#9b59b6'];
            const soundTypeColor = soundTypeColors[Math.round(soundType)] || '#95a5a6';
            
            const soundTypeElement = document.getElementById('soundType');
            soundTypeElement.textContent = soundTypeName;
            soundTypeElement.style.color = soundTypeColor;
            
            const intensityLevel = (latest.intensity_level || 0) * 100;
            const intensityElement = document.getElementById('intensityLevel');
            intensityElement.textContent = intensityLevel.toFixed(1) + '%';
            
            // ê°•ë„ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€ê²½
            if (intensityLevel > 70) {
                intensityElement.style.color = '#e74c3c'; // ë¹¨ê°„ìƒ‰
            } else if (intensityLevel > 40) {
                intensityElement.style.color = '#f39c12'; // ì£¼í™©ìƒ‰
            } else {
                intensityElement.style.color = '#27ae60'; // ì´ˆë¡ìƒ‰
            }

            // ìƒíƒœ ë°” ì—…ë°ì´íŠ¸
            document.getElementById('deviceCount').textContent = new Set(data.map(d => d.device_id)).size;
            document.getElementById('dataCount').textContent = data.length;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            document.getElementById('updateTime').textContent = new Date().toLocaleTimeString();

            // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
            updateCharts(data);
            updateRecentDataTable(data);

            // ì•Œë¦¼ ì²´í¬
            checkAlerts(latest);
        }

        // ì••ì¶•ê¸° ìƒíƒœ ë¶„ì„ (45dB ê¸°ì¤€)
        function updateCompressorAnalysis(data) {
            if (!data || data.length === 0) return;

            // ë°ì‹œë²¨ ê°’ ê³„ì‚°
            const decibelValues = data.map(d => rmsToDecibel(d.rms_energy));
            
            // ì••ì¶•ê¸° ìƒíƒœ ë¶„ë¥˜ (45dB ê¸°ì¤€)
            let onCount = 0;
            let offCount = 0;
            const compressorStates = [];

            decibelValues.forEach((db, index) => {
                let state;
                if (db >= 45) {
                    state = 1; // ON (45dB ì´ìƒ)
                    onCount++;
                } else {
                    state = 0; // OFF (45dB ë¯¸ë§Œ)
                    offCount++;
                }
                compressorStates.push(state);
            });

            // ë¹„ìœ¨ ê³„ì‚°
            const total = data.length;
            const onPercentage = total > 0 ? Math.round((onCount / total) * 100) : 0;
            const offPercentage = total > 0 ? Math.round((offCount / total) * 100) : 0;

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('onPercentage').textContent = onPercentage + '%';
            document.getElementById('offPercentage').textContent = offPercentage + '%';
            document.getElementById('totalMeasurements').textContent = total;
            document.getElementById('onCount').textContent = onCount;
            document.getElementById('offCount').textContent = offCount;

            // ì••ì¶•ê¸° ìƒíƒœ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            updateCompressorStateChart(data, compressorStates);
        }

        // ì••ì¶•ê¸° ìƒíƒœ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateCompressorStateChart(data, states) {
            if (!charts.compressorState) {
                const ctx = document.getElementById('compressorStateChart').getContext('2d');
                charts.compressorState = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ì••ì¶•ê¸° ìƒíƒœ',
                            data: [],
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }, {
                            label: 'ë°ì‹œë²¨ ë ˆë²¨',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                min: 0,
                                max: 1,
                                ticks: {
                                    callback: function(value) {
                                        if (value === 1) return 'ON';
                                        if (value === 0) return 'OFF';
                                        return 'ì¤‘ê°„';
                                    }
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                min: 0,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value + ' dB';
                                    }
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const db = rmsToDecibel(data[context.dataIndex].rms_energy);
                                            return `ë°ì‹œë²¨: ${db.toFixed(1)} dB`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // ìµœê·¼ 50ê°œ ë°ì´í„°ë§Œ í‘œì‹œ
            const limit = Math.min(50, data.length);
            const labels = Array.from({length: limit}, (_, i) => i + 1);
            const decibelValues = data.slice(0, limit).map(d => rmsToDecibel(d.rms_energy));

            charts.compressorState.data.labels = labels;
            charts.compressorState.data.datasets[0].data = states.slice(0, limit);
            charts.compressorState.data.datasets[1].data = decibelValues;
            charts.compressorState.update();
        }

        // ì••ì¶•ê¸° ì‘ë™ íŒ¨í„´ ë¶„ì„ (ì‚¬ì´í´ë³„ ì´ìƒ ê°ì§€)
        function analyzeCompressorPattern(data) {
            if (!data || data.length === 0) return;

            // 45dB ê¸°ì¤€ìœ¼ë¡œ ì••ì¶•ê¸° ìƒíƒœ ê³„ì‚°
            const compressorStates = data.map(d => rmsToDecibel(d.rms_energy) >= 45 ? 1 : 0);

            // ì‚¬ì´í´ë³„ ë¶„ì„
            let cycles = [];
            let currentCycle = { onTime: 0, offTime: 0, totalTime: 0, onRatio: 0 };
            let isOn = false;
            let cycleCount = 0;

            for (let i = 0; i < compressorStates.length; i++) {
                const isCurrentlyOn = compressorStates[i] === 1;

                if (isCurrentlyOn && !isOn) {
                    // OFF -> ON ì „í™˜ (ìƒˆ ì‚¬ì´í´ ì‹œì‘)
                    if (currentCycle.totalTime > 0) {
                        currentCycle.onRatio = currentCycle.onTime / currentCycle.totalTime;
                        cycles.push({...currentCycle});
                    }
                    currentCycle = { onTime: 0, offTime: 0, totalTime: 0, onRatio: 0 };
                    isOn = true;
                    cycleCount++;
                } else if (!isCurrentlyOn && isOn) {
                    // ON -> OFF ì „í™˜
                    isOn = false;
                }

                if (isOn) {
                    currentCycle.onTime++;
                } else {
                    currentCycle.offTime++;
                }
                currentCycle.totalTime++;
            }

            // ë§ˆì§€ë§‰ ì‚¬ì´í´ ì²˜ë¦¬
            if (currentCycle.totalTime > 0) {
                currentCycle.onRatio = currentCycle.onTime / currentCycle.totalTime;
                cycles.push(currentCycle);
            }

            // ì´ìƒ ê°ì§€ ë¶„ì„
            const anomalyAnalysis = detectPatternAnomalies(cycles);
            
            // í†µê³„ ê³„ì‚°
            const avgOnTime = cycles.length > 0 ? Math.round(cycles.reduce((sum, cycle) => sum + cycle.onTime, 0) / cycles.length) : 0;
            const avgOffTime = cycles.length > 0 ? Math.round(cycles.reduce((sum, cycle) => sum + cycle.offTime, 0) / cycles.length) : 0;
            const avgOnRatio = cycles.length > 0 ? (cycles.reduce((sum, cycle) => sum + cycle.onRatio, 0) / cycles.length * 100) : 0;

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('avgOnTime').textContent = avgOnTime > 0 ? `${avgOnTime}ë¶„` : '-';
            document.getElementById('avgOffTime').textContent = avgOffTime > 0 ? `${avgOffTime}ë¶„` : '-';
            document.getElementById('cycleCount').textContent = cycleCount > 0 ? `${cycleCount}íšŒ` : '-';

            // ì´ìƒ ê°ì§€ ì ìˆ˜ ì—…ë°ì´íŠ¸
            updateAnomalyScore(anomalyAnalysis.anomalyScore);
            
            // íš¨ìœ¨ì„± ë° ì•ˆì •ì„± ê³„ì‚°
            const efficiency = typeof avgOnRatio === 'number' && avgOnRatio > 0 ? avgOnRatio : 0;
            const stability = typeof anomalyAnalysis.anomalyScore === 'number' ? (100 - anomalyAnalysis.anomalyScore) : 100;
            
            // UI ì—…ë°ì´íŠ¸
            document.getElementById('efficiency').textContent = efficiency > 0 ? `${Number(efficiency).toFixed(1)}%` : '-';
            document.getElementById('stability').textContent = stability > 0 ? `${Number(stability).toFixed(0)}%` : '-';
            
            // ì˜¨ë„ ì •ë³´ ì—…ë°ì´íŠ¸
            if (anomalyAnalysis.weatherData) {
                document.getElementById('currentTemp').textContent = `${anomalyAnalysis.weatherData.temperature}Â°C`;
                if (anomalyAnalysis.normalRange) {
                    document.getElementById('expectedRatio').textContent = `${(anomalyAnalysis.normalRange.predicted * 100).toFixed(1)}%`;
                    document.getElementById('tempEfficiency').textContent = `${anomalyAnalysis.normalRange.efficiency}ì `;
                }
            } else {
                document.getElementById('currentTemp').textContent = 'ë°ì´í„° ì—†ìŒ';
                document.getElementById('expectedRatio').textContent = '-';
                document.getElementById('tempEfficiency').textContent = '-';
            }
            
            // íŠ¸ë Œë“œ í‘œì‹œ
            const trendElement = document.getElementById('patternTrend');
            if (trendElement) {
                const trendText = {
                    'increasing': 'ğŸ“ˆ ì¦ê°€',
                    'decreasing': 'ğŸ“‰ ê°ì†Œ', 
                    'stable': 'â¡ï¸ ì•ˆì •',
                    'insufficient_data': 'â“ ë°ì´í„° ë¶€ì¡±'
                };
                trendElement.textContent = trendText[anomalyAnalysis.trend] || 'â“';
                
                // íŠ¸ë Œë“œì— ë”°ë¥¸ ìƒ‰ìƒ
                if (anomalyAnalysis.trend === 'increasing') {
                    trendElement.style.color = '#e74c3c';
                } else if (anomalyAnalysis.trend === 'decreasing') {
                    trendElement.style.color = '#3498db';
                } else {
                    trendElement.style.color = '#27ae60';
                }
            }
            
            // ê°œì„ ëœ ì‚¬ì´í´ íŒ¨í„´ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            updateImprovedCycleChart(cycles, anomalyAnalysis);

            // ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„ ë¶„ì„
            analyzeTemperatureCorrelation(cycles, anomalyAnalysis);

            return {
                cycles,
                cycleCount,
                avgOnTime,
                avgOffTime,
                avgOnRatio,
                anomalyAnalysis
            };
        }

        // ì˜¨ë„ ê¸°ë°˜ ì§€ëŠ¥í˜• ì´ìƒ ê°ì§€ ì‹œìŠ¤í…œ
        let weatherData = null;
        let lastWeatherUpdate = 0;
        const WEATHER_UPDATE_INTERVAL = 30 * 60 * 1000; // 30ë¶„ë§ˆë‹¤ ì—…ë°ì´íŠ¸

        // ê¸°ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì„œë²„ API ì‚¬ìš©)
        async function fetchWeatherData() {
            const now = Date.now();
            if (now - lastWeatherUpdate < WEATHER_UPDATE_INTERVAL && weatherData) {
                return weatherData;
            }

            try {
                // ì„œë²„ì˜ ê¸°ìƒ API ì‚¬ìš© (ì„œë²„ì—ì„œ ìºì‹±ë¨)
                const response = await fetch('/api/weather/current');
                const data = await response.json();
                
                if (data.success) {
                    weatherData = {
                        temperature: data.temperature,
                        humidity: data.humidity,
                        timestamp: now,
                        location: data.location
                    };
                    lastWeatherUpdate = now;
                    
                    console.log('ğŸŒ¡ï¸ ê¸°ìƒ ë°ì´í„° ì—…ë°ì´íŠ¸:', weatherData);
                    return weatherData;
                } else {
                    console.error('ê¸°ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', data.message);
                    return null;
                }
            } catch (error) {
                console.error('ê¸°ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
                return null;
            }
        }

        // ì˜¨ë„-ì••ì¶•ê¸° ë™ì‘ ìƒê´€ê´€ê³„ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜
        function predictNormalOperationRange(temperature, timeOfDay) {
            // ê³„ì ˆë³„ ê¸°ë³¸ ì‘ë™ ë¹„ìœ¨ (ì˜¨ë„ë³„)
            let baseOperationRatio;
            if (temperature < 0) {
                baseOperationRatio = 0.8; // ë§¤ìš° ì¶”ìš´ ë‚ : 80% ì‘ë™
            } else if (temperature < 10) {
                baseOperationRatio = 0.7; // ì¶”ìš´ ë‚ : 70% ì‘ë™
            } else if (temperature < 20) {
                baseOperationRatio = 0.5; // ì ë‹¹í•œ ë‚ : 50% ì‘ë™
            } else if (temperature < 30) {
                baseOperationRatio = 0.3; // ë”°ëœ»í•œ ë‚ : 30% ì‘ë™
            } else {
                baseOperationRatio = 0.2; // ë”ìš´ ë‚ : 20% ì‘ë™
            }
            
            // ì‹œê°„ëŒ€ ê³„ìˆ˜ (ë‚®/ë°¤ íŒ¨í„´)
            let timeCoefficient;
            if (timeOfDay >= 22 || timeOfDay <= 6) {
                timeCoefficient = 0.6; // ë°¤ì‹œê°„: 60% ê°ì†Œ
            } else if (timeOfDay >= 7 && timeOfDay <= 9) {
                timeCoefficient = 1.2; // ì•„ì¹¨ ì¶œê·¼ì‹œê°„: 20% ì¦ê°€
            } else if (timeOfDay >= 18 && timeOfDay <= 21) {
                timeCoefficient = 1.1; // ì €ë… ì‹œê°„: 10% ì¦ê°€
            } else {
                timeCoefficient = 1.0; // ì¼ë°˜ ì‹œê°„
            }
            
            // ì˜ˆì¸¡ëœ ì •ìƒ ì‘ë™ ë¹„ìœ¨
            const predictedRatio = baseOperationRatio * timeCoefficient;
            
            // ì˜¨ë„ë³„ í—ˆìš© ì˜¤ì°¨ ë²”ìœ„ (ì˜¨ë„ê°€ ê·¹ë‹¨ì ì¼ìˆ˜ë¡ ì˜¤ì°¨ ë²”ìœ„ ì¦ê°€)
            let tolerance;
            if (temperature < 0 || temperature > 35) {
                tolerance = 0.3; // ê·¹í•œ ì˜¨ë„: 30% ì˜¤ì°¨ í—ˆìš©
            } else if (temperature < 5 || temperature > 30) {
                tolerance = 0.25; // ê·¹í•œì— ê°€ê¹Œìš´ ì˜¨ë„: 25% ì˜¤ì°¨ í—ˆìš©
            } else {
                tolerance = 0.2; // ì¼ë°˜ ì˜¨ë„: 20% ì˜¤ì°¨ í—ˆìš©
            }
            
            return {
                min: Math.max(0, predictedRatio - tolerance),
                max: Math.min(1, predictedRatio + tolerance),
                predicted: predictedRatio,
                temperature: temperature,
                timeOfDay: timeOfDay,
                efficiency: calculateEfficiencyScore(temperature, timeOfDay, predictedRatio)
            };
        }

        // íš¨ìœ¨ì„± ì ìˆ˜ ê³„ì‚° (0-100ì )
        function calculateEfficiencyScore(temperature, timeOfDay, predictedRatio) {
            // ì˜¨ë„ íš¨ìœ¨ì„± (ì ì • ì˜¨ë„ ë²”ìœ„ì—ì„œ ë†’ì€ ì ìˆ˜)
            let tempEfficiency = 100;
            if (temperature < 0 || temperature > 35) {
                tempEfficiency = 30; // ê·¹í•œ ì˜¨ë„
            } else if (temperature < 5 || temperature > 30) {
                tempEfficiency = 60; // ê·¹í•œì— ê°€ê¹Œìš´ ì˜¨ë„
            } else if (temperature >= 10 && temperature <= 25) {
                tempEfficiency = 100; // ìµœì  ì˜¨ë„
            } else {
                tempEfficiency = 80; // ì–‘í˜¸í•œ ì˜¨ë„
            }
            
            // ì‹œê°„ëŒ€ íš¨ìœ¨ì„±
            let timeEfficiency = 100;
            if (timeOfDay >= 22 || timeOfDay <= 6) {
                timeEfficiency = 70; // ë°¤ì‹œê°„
            } else if (timeOfDay >= 7 && timeOfDay <= 9) {
                timeEfficiency = 90; // ì•„ì¹¨ ì¶œê·¼ì‹œê°„
            } else {
                timeEfficiency = 100; // ì¼ë°˜ ì‹œê°„
            }
            
            // ì¢…í•© íš¨ìœ¨ì„± ì ìˆ˜
            return Math.round((tempEfficiency * 0.7 + timeEfficiency * 0.3));
        }

        // íŒ¨í„´ ì´ìƒ ê°ì§€ ì•Œê³ ë¦¬ì¦˜ (ì˜¨ë„ ê¸°ë°˜)
        async function detectPatternAnomalies(cycles) {
            if (cycles.length < 3) {
                return { anomalyScore: 0, anomalies: [], trend: 'insufficient_data' };
            }

            // 1. ê¸°ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const weather = await fetchWeatherData();
            const currentTime = new Date();
            const timeOfDay = currentTime.getHours();
            
            const recentCycles = cycles.slice(-5); // ìµœê·¼ 5ê°œ ì‚¬ì´í´
            const onTimes = recentCycles.map(cycle => cycle.onTime);
            const onRatios = recentCycles.map(cycle => cycle.onRatio);
            
            // 2. ì˜¨ë„ ê¸°ë°˜ ì •ìƒ ë²”ìœ„ ì˜ˆì¸¡
            let normalRange = null;
            if (weather) {
                normalRange = predictNormalOperationRange(weather.temperature, timeOfDay);
            }
            
            // 3. ê¸°ë³¸ í†µê³„ ê³„ì‚°
            const avgOnTime = onTimes.reduce((sum, time) => sum + time, 0) / onTimes.length;
            const avgOnRatio = onRatios.reduce((sum, ratio) => sum + ratio, 0) / onRatios.length;
            const currentOnRatio = onRatios[onRatios.length - 1];
            
            let anomalyScore = 0;
            const anomalies = [];
            
            // 4. ì˜¨ë„ ê¸°ë°˜ ì´ìƒ ê°ì§€
            if (normalRange) {
                const isWithinNormalRange = currentOnRatio >= normalRange.min && currentOnRatio <= normalRange.max;
                
                if (!isWithinNormalRange) {
                    const deviation = Math.abs(currentOnRatio - normalRange.predicted);
                    const severity = Math.min(deviation / 0.2, 1); // 20% ì´ìƒ ë²—ì–´ë‚˜ë©´ ìµœëŒ€ ì ìˆ˜
                    anomalyScore = Math.max(anomalyScore, severity);
                    
                    if (currentOnRatio > normalRange.max) {
                        anomalies.push(`ì˜¨ë„ ëŒ€ë¹„ ê³¼ë¶€í•˜: ${(currentOnRatio * 100).toFixed(1)}% (ì˜ˆìƒ: ${(normalRange.predicted * 100).toFixed(1)}%, ì˜¨ë„: ${weather.temperature}Â°C)`);
                    } else {
                        anomalies.push(`ì˜¨ë„ ëŒ€ë¹„ ì €ë¶€í•˜: ${(currentOnRatio * 100).toFixed(1)}% (ì˜ˆìƒ: ${(normalRange.predicted * 100).toFixed(1)}%, ì˜¨ë„: ${weather.temperature}Â°C)`);
                    }
                } else {
                    anomalies.push(`ì •ìƒ ì‘ë™ ë²”ìœ„ ë‚´ (ì˜¨ë„: ${weather.temperature}Â°C, ì˜ˆìƒ: ${(normalRange.predicted * 100).toFixed(1)}%)`);
                }
            } else {
                // 5. ê¸°ìƒ ë°ì´í„° ì—†ì„ ë•Œ ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
                const timeVariance = onTimes.reduce((sum, time) => sum + Math.pow(time - avgOnTime, 2), 0) / onTimes.length;
                const ratioVariance = onRatios.reduce((sum, ratio) => sum + Math.pow(ratio - avgOnRatio, 2), 0) / onRatios.length;
                const timeStdDev = Math.sqrt(timeVariance);
                const ratioStdDev = Math.sqrt(ratioVariance);
                
                if (timeStdDev > 0) {
                    const timeZScore = Math.abs(onTimes[onTimes.length - 1] - avgOnTime) / timeStdDev;
                    anomalyScore = Math.max(anomalyScore, Math.min(timeZScore / 2, 1));
                }
                
                if (ratioStdDev > 0) {
                    const ratioZScore = Math.abs(currentOnRatio - avgOnRatio) / ratioStdDev;
                    anomalyScore = Math.max(anomalyScore, Math.min(ratioZScore / 2, 1));
                }
            }
            
            // 6. íŠ¸ë Œë“œ ë¶„ì„
            let trend = 'stable';
            if (onTimes.length >= 3) {
                const recentTrend = onTimes.slice(-3);
                const isIncreasing = recentTrend[2] > recentTrend[1] && recentTrend[1] > recentTrend[0];
                const isDecreasing = recentTrend[2] < recentTrend[1] && recentTrend[1] < recentTrend[0];
                
                if (isIncreasing) trend = 'increasing';
                else if (isDecreasing) trend = 'decreasing';
            }
            
            // 7. ì¢…í•© ì´ìƒ ì ìˆ˜ (0-100ì )
            const finalScore = Math.round(anomalyScore * 100);
            
            return {
                anomalyScore: finalScore,
                anomalies,
                trend,
                avgOnRatio: avgOnRatio * 100,
                currentOnRatio: currentOnRatio * 100,
                avgOnTime: avgOnTime,
                currentOnTime: onTimes[onTimes.length - 1],
                weatherData: weather,
                normalRange: normalRange
            };
        }

        // ì´ìƒ ê°ì§€ ì ìˆ˜ ì—…ë°ì´íŠ¸ (0-100ì )
        function updateAnomalyScore(score) {
            const anomalyElement = document.getElementById('currentAnomaly');
            if (anomalyElement) {
                anomalyElement.textContent = `${score}ì `;
                
                // ìƒ‰ìƒ ë³€ê²½ (0-100ì  ê¸°ì¤€)
                if (score >= 70) {
                    anomalyElement.style.color = '#e74c3c'; // ë¹¨ê°„ìƒ‰ - ìœ„í—˜
                } else if (score >= 40) {
                    anomalyElement.style.color = '#f39c12'; // ì£¼í™©ìƒ‰ - ì£¼ì˜
                } else if (score >= 20) {
                    anomalyElement.style.color = '#f1c40f'; // ë…¸ë€ìƒ‰ - ê²½ê³ 
                } else {
                    anomalyElement.style.color = '#27ae60'; // ì´ˆë¡ìƒ‰ - ì •ìƒ
                }
            }
        }

        // í†µí•©ëœ ì‘ë™ íŒ¨í„´ íë¦„ ì°¨íŠ¸
        function updateImprovedCycleChart(cycles, anomalyAnalysis) {
            if (!charts.cyclePattern) {
                const ctx = document.getElementById('cyclePatternChart').getContext('2d');
                charts.cyclePattern = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ì‘ë™ íŒ¨í„´ íë¦„',
                            data: [],
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }, {
                            label: 'í‰ê·  ì‘ë™ ì‹œê°„',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0
                        }, {
                            label: 'ì´ìƒ ì„ê³„ê°’',
                            data: [],
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            borderWidth: 1,
                            borderDash: [3, 3],
                            fill: false,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'ì‘ë™ ì‹œê°„ (ë¶„)'
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'ì‹œê°„ íë¦„'
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const dataIndex = context.dataIndex;
                                        if (dataIndex < cycles.length) {
                                            const cycle = cycles[dataIndex];
                                            const onRatio = (cycle.onRatio * 100).toFixed(1);
                                            return [
                                                `ì‘ë™ ë¹„ìœ¨: ${onRatio}%`,
                                                `ì´ ì‹œê°„: ${cycle.totalTime}ë¶„`,
                                                `íš¨ìœ¨ì„±: ${cycle.onRatio > 0.5 ? 'ë†’ìŒ' : 'ë‚®ìŒ'}`
                                            ];
                                        }
                                        return '';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // ëª¨ë“  ì‚¬ì´í´ì„ ì‹œê°„ ìˆœì„œëŒ€ë¡œ í‘œì‹œ
            const labels = cycles.map((_, index) => `C${index + 1}`);
            const onTimes = cycles.map(cycle => cycle.onTime);
            
            // í‰ê·  ì‘ë™ ì‹œê°„ ê³„ì‚°
            const avgOnTime = onTimes.length > 0 ? onTimes.reduce((sum, time) => sum + time, 0) / onTimes.length : 0;
            const avgLine = new Array(onTimes.length).fill(avgOnTime);
            
            // ì´ìƒ ì„ê³„ê°’ (í‰ê·  Â± 1.5Ïƒ)
            const variance = onTimes.reduce((sum, time) => sum + Math.pow(time - avgOnTime, 2), 0) / onTimes.length;
            const stdDev = Math.sqrt(variance);
            const threshold = new Array(onTimes.length).fill(avgOnTime + 1.5 * stdDev);

            charts.cyclePattern.data.labels = labels;
            charts.cyclePattern.data.datasets[0].data = onTimes;
            charts.cyclePattern.data.datasets[1].data = avgLine;
            charts.cyclePattern.data.datasets[2].data = threshold;
            charts.cyclePattern.update();
        }

        // ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„ ë¶„ì„ (ì‹¤ì œ ì„¼ì„œ ë°ì´í„° ì‚¬ìš©)
        async function analyzeTemperatureCorrelation(cycles, anomalyAnalysis) {
            try {
                // ì‹¤ì œ ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const sensorResponse = await fetch('/api/sensor/correlation?hours=24');
                
                if (!sensorResponse.ok) {
                    throw new Error(`ì„¼ì„œ ë°ì´í„° API ì˜¤ë¥˜: ${sensorResponse.status}`);
                }
                
                const sensorData = await sensorResponse.json();
                
                if (!sensorData.success || !sensorData.data || sensorData.data.length === 0) {
                    console.log('ì„¼ì„œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ëª¨ì˜ ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                    return analyzeTemperatureCorrelationMock(cycles, anomalyAnalysis);
                }

                const correlationData = sensorData.correlation_data;
                const summary = sensorData.summary;

                // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¡œ ë¶„ì„
                const correlation = calculateRealCorrelation(correlationData);
                const tempSensitivity = calculateRealTempSensitivity(correlationData);
                const predictionAccuracy = calculateRealPredictionAccuracy(correlationData, anomalyAnalysis.normalRange);
                const energyEfficiency = calculateRealEnergyEfficiency(correlationData);

                // UI ì—…ë°ì´íŠ¸
                document.getElementById('correlationCoeff').textContent = correlation.toFixed(3);
                document.getElementById('tempSensitivity').textContent = `${tempSensitivity.toFixed(1)}%`;
                document.getElementById('predictionAccuracy').textContent = `${predictionAccuracy.toFixed(1)}%`;
                document.getElementById('energyEfficiency').textContent = `${energyEfficiency.toFixed(1)}%`;

                // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¡œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                updateRealTemperatureCorrelationChart(correlationData, summary);

            } catch (error) {
                console.error('ì„¼ì„œ ë°ì´í„° ë¶„ì„ ì˜¤ë¥˜:', error);
                // ì˜¤ë¥˜ ì‹œ ëª¨ì˜ ë°ì´í„° ì‚¬ìš©
                analyzeTemperatureCorrelationMock(cycles, anomalyAnalysis);
            }
        }

        // ëª¨ì˜ ë°ì´í„°ë¥¼ ì‚¬ìš©í•œ ë¶„ì„ (ê¸°ì¡´ ë¡œì§)
        function analyzeTemperatureCorrelationMock(cycles, anomalyAnalysis) {
            if (!anomalyAnalysis.weatherData || cycles.length < 3) return;

            const temperature = anomalyAnalysis.weatherData.temperature;
            const onRatios = cycles.map(cycle => cycle.onRatio);
            const avgOnRatio = onRatios.reduce((sum, ratio) => sum + ratio, 0) / onRatios.length;

            // ìƒê´€ê³„ìˆ˜ ê³„ì‚° (ì˜¨ë„ì™€ ì‘ë™ ë¹„ìœ¨)
            const correlation = calculateCorrelation(temperature, avgOnRatio);
            
            // ì˜¨ë„ ë¯¼ê°ë„ ê³„ì‚°
            const tempSensitivity = calculateTemperatureSensitivity(cycles, temperature);
            
            // ì˜ˆì¸¡ ì •í™•ë„ ê³„ì‚°
            const predictionAccuracy = calculatePredictionAccuracy(cycles, anomalyAnalysis.normalRange);
            
            // ì—ë„ˆì§€ íš¨ìœ¨ì„± ê³„ì‚°
            const energyEfficiency = calculateEnergyEfficiency(cycles, temperature);

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('correlationCoeff').textContent = correlation.toFixed(3);
            document.getElementById('tempSensitivity').textContent = `${tempSensitivity.toFixed(1)}%`;
            document.getElementById('predictionAccuracy').textContent = `${predictionAccuracy.toFixed(1)}%`;
            document.getElementById('energyEfficiency').textContent = `${energyEfficiency.toFixed(1)}%`;

            // ìƒê´€ê´€ê³„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            updateTemperatureCorrelationChart(cycles, temperature, anomalyAnalysis);
        }

        // ìƒê´€ê³„ìˆ˜ ê³„ì‚°
        function calculateCorrelation(temperature, avgOnRatio) {
            // ê°„ë‹¨í•œ ìƒê´€ê³„ìˆ˜ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë°ì´í„°ê°€ í•„ìš”)
            const tempRange = 40; // -10ë„ ~ 30ë„
            const normalizedTemp = (temperature + 10) / tempRange; // 0~1 ì •ê·œí™”
            const expectedRatio = Math.max(0, 1 - normalizedTemp); // ì˜¨ë„ê°€ ë‚®ì„ìˆ˜ë¡ ì‘ë™ ë¹„ìœ¨ ì¦ê°€
            
            const correlation = 1 - Math.abs(avgOnRatio - expectedRatio);
            return Math.max(-1, Math.min(1, correlation));
        }

        // ì˜¨ë„ ë¯¼ê°ë„ ê³„ì‚°
        function calculateTemperatureSensitivity(cycles, temperature) {
            if (cycles.length < 2) return 0;
            
            const onRatios = cycles.map(cycle => cycle.onRatio);
            const ratioVariance = onRatios.reduce((sum, ratio) => sum + Math.pow(ratio - (onRatios.reduce((a, b) => a + b, 0) / onRatios.length), 2), 0) / onRatios.length;
            const stdDev = Math.sqrt(ratioVariance);
            
            // ì˜¨ë„ ë³€í™”ì— ëŒ€í•œ ë¯¼ê°ë„ (í‘œì¤€í¸ì°¨ ê¸°ë°˜)
            return Math.min(100, stdDev * 200);
        }

        // ì˜ˆì¸¡ ì •í™•ë„ ê³„ì‚°
        function calculatePredictionAccuracy(cycles, normalRange) {
            if (!normalRange || cycles.length === 0) return 0;
            
            const currentRatio = cycles[cycles.length - 1].onRatio;
            const isWithinRange = currentRatio >= normalRange.min && currentRatio <= normalRange.max;
            
            if (isWithinRange) {
                const deviation = Math.abs(currentRatio - normalRange.predicted);
                return Math.max(0, 100 - (deviation * 200));
            } else {
                return 0;
            }
        }

        // ì—ë„ˆì§€ íš¨ìœ¨ì„± ê³„ì‚°
        function calculateEnergyEfficiency(cycles, temperature) {
            if (cycles.length === 0) return 0;
            
            const avgOnRatio = cycles.reduce((sum, cycle) => sum + cycle.onRatio, 0) / cycles.length;
            
            // ì˜¨ë„ë³„ ìµœì  ì‘ë™ ë¹„ìœ¨
            let optimalRatio;
            if (temperature < 0) optimalRatio = 0.8;
            else if (temperature < 10) optimalRatio = 0.7;
            else if (temperature < 20) optimalRatio = 0.5;
            else if (temperature < 30) optimalRatio = 0.3;
            else optimalRatio = 0.2;
            
            const efficiency = Math.max(0, 100 - Math.abs(avgOnRatio - optimalRatio) * 200);
            return Math.min(100, efficiency);
        }

        // ì˜¨ë„-ì••ì¶•ê¸° ìƒê´€ê´€ê³„ ì°¨íŠ¸
        function updateTemperatureCorrelationChart(cycles, temperature, anomalyAnalysis) {
            if (!charts.temperatureCorrelation) {
                const ctx = document.getElementById('temperatureCorrelationChart').getContext('2d');
                charts.temperatureCorrelation = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'ì˜¨ë„ vs ì‘ë™ë¹„ìœ¨',
                            data: [],
                            backgroundColor: 'rgba(52, 152, 219, 0.6)',
                            borderColor: '#3498db',
                            borderWidth: 2
                        }, {
                            label: 'ì˜ˆì¸¡ ë²”ìœ„',
                            data: [],
                            type: 'line',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderColor: '#e74c3c',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'ì˜¨ë„ (Â°C)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'ì‘ë™ ë¹„ìœ¨ (%)'
                                },
                                min: 0,
                                max: 100
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        }
                    }
                });
            }

            // ë°ì´í„° í¬ì¸íŠ¸ ìƒì„±
            const dataPoints = cycles.map((cycle, index) => ({
                x: temperature + (Math.random() - 0.5) * 2, // ì•½ê°„ì˜ ì˜¨ë„ ë³€í™” ì‹œë®¬ë ˆì´ì…˜
                y: cycle.onRatio * 100
            }));

            // ì˜ˆì¸¡ ë²”ìœ„ ë°ì´í„°
            const predictionData = [];
            for (let temp = temperature - 10; temp <= temperature + 10; temp += 2) {
                const range = predictNormalOperationRange(temp, new Date().getHours());
                predictionData.push({
                    x: temp,
                    y: range.predicted * 100
                });
            }

            charts.temperatureCorrelation.data.datasets[0].data = dataPoints;
            charts.temperatureCorrelation.data.datasets[1].data = predictionData;
            charts.temperatureCorrelation.update();
        }

        // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•œ ë¶„ì„ í•¨ìˆ˜ë“¤
        function calculateRealCorrelation(correlationData) {
            if (correlationData.length < 2) return 0;
            
            // ì˜¨ë„ì™€ ì‘ë™ ë¹„ìœ¨ì˜ ìƒê´€ê³„ìˆ˜ ê³„ì‚°
            const temps = correlationData.map(d => d.temperature);
            const ratios = correlationData.map(d => d.on_ratio);
            
            const avgTemp = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
            const avgRatio = ratios.reduce((sum, ratio) => sum + ratio, 0) / ratios.length;
            
            let numerator = 0;
            let tempSumSq = 0;
            let ratioSumSq = 0;
            
            for (let i = 0; i < temps.length; i++) {
                const tempDiff = temps[i] - avgTemp;
                const ratioDiff = ratios[i] - avgRatio;
                
                numerator += tempDiff * ratioDiff;
                tempSumSq += tempDiff * tempDiff;
                ratioSumSq += ratioDiff * ratioDiff;
            }
            
            const denominator = Math.sqrt(tempSumSq * ratioSumSq);
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function calculateRealTempSensitivity(correlationData) {
            if (correlationData.length < 2) return 0;
            
            // ì˜¨ë„ ë³€í™”ì— ë”°ë¥¸ ì‘ë™ ë¹„ìœ¨ ë³€í™”ì˜ í‘œì¤€í¸ì°¨
            const ratios = correlationData.map(d => d.on_ratio);
            const avgRatio = ratios.reduce((sum, ratio) => sum + ratio, 0) / ratios.length;
            const variance = ratios.reduce((sum, ratio) => sum + Math.pow(ratio - avgRatio, 2), 0) / ratios.length;
            const stdDev = Math.sqrt(variance);
            
            return Math.min(100, stdDev * 200);
        }

        function calculateRealPredictionAccuracy(correlationData, normalRange) {
            if (!normalRange || correlationData.length === 0) return 0;
            
            let correctPredictions = 0;
            correlationData.forEach(data => {
                const isWithinRange = data.on_ratio >= normalRange.min && data.on_ratio <= normalRange.max;
                if (isWithinRange) correctPredictions++;
            });
            
            return (correctPredictions / correlationData.length) * 100;
        }

        function calculateRealEnergyEfficiency(correlationData) {
            if (correlationData.length === 0) return 0;
            
            let totalEfficiency = 0;
            correlationData.forEach(data => {
                // ì˜¨ë„ë³„ ìµœì  ì‘ë™ ë¹„ìœ¨
                let optimalRatio;
                if (data.temperature < 0) optimalRatio = 0.8;
                else if (data.temperature < 10) optimalRatio = 0.7;
                else if (data.temperature < 20) optimalRatio = 0.5;
                else if (data.temperature < 30) optimalRatio = 0.3;
                else optimalRatio = 0.2;
                
                const efficiency = Math.max(0, 100 - Math.abs(data.on_ratio - optimalRatio) * 200);
                totalEfficiency += efficiency;
            });
            
            return totalEfficiency / correlationData.length;
        }

        // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateRealTemperatureCorrelationChart(correlationData, summary) {
            if (!charts.temperatureCorrelation) {
                const ctx = document.getElementById('temperatureCorrelationChart').getContext('2d');
                charts.temperatureCorrelation = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'ì‹¤ì œ ì„¼ì„œ ë°ì´í„°',
                            data: [],
                            backgroundColor: 'rgba(52, 152, 219, 0.6)',
                            borderColor: '#3498db',
                            borderWidth: 2
                        }, {
                            label: 'ì˜ˆì¸¡ ë²”ìœ„',
                            data: [],
                            type: 'line',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderColor: '#e74c3c',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'ì˜¨ë„ (Â°C)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'ì‘ë™ ë¹„ìœ¨ (%)'
                                },
                                min: 0,
                                max: 100
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const dataIndex = context.dataIndex;
                                        if (dataIndex < correlationData.length) {
                                            const data = correlationData[dataIndex];
                                            return [
                                                `ë°ì´í„° í¬ì¸íŠ¸: ${data.total_count}ê°œ`,
                                                `í‰ê·  ë°ì‹œë²¨: ${data.avg_decibel.toFixed(1)}dB`,
                                                `í‰ê·  ì „ë ¥: ${data.avg_power.toFixed(1)}W`
                                            ];
                                        }
                                        return '';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // ì‹¤ì œ ì„¼ì„œ ë°ì´í„° í¬ì¸íŠ¸
            const dataPoints = correlationData.map(data => ({
                x: data.temperature,
                y: data.on_ratio * 100
            }));

            // ì˜ˆì¸¡ ë²”ìœ„ ë°ì´í„° (ì˜¨ë„ ë²”ìœ„ì— ë§ì¶° ìƒì„±)
            const predictionData = [];
            const minTemp = Math.min(...correlationData.map(d => d.temperature));
            const maxTemp = Math.max(...correlationData.map(d => d.temperature));
            
            for (let temp = minTemp - 5; temp <= maxTemp + 5; temp += 2) {
                const range = predictNormalOperationRange(temp, new Date().getHours());
                predictionData.push({
                    x: temp,
                    y: range.predicted * 100
                });
            }

            charts.temperatureCorrelation.data.datasets[0].data = dataPoints;
            charts.temperatureCorrelation.data.datasets[1].data = predictionData;
            charts.temperatureCorrelation.update();
        }

        // ê´€ë¦¬ììš© ì¶”ì„¸ ë¶„ì„ í•¨ìˆ˜ë“¤
        let currentTrendPeriod = 'daily';

        function showTrendAnalysis(period) {
            currentTrendPeriod = period;
            
            // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.trend-controls .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ì¶”ì„¸ ë¶„ì„ ì‹¤í–‰
            analyzeTrends(period);
        }

        async function analyzeTrends(period) {
            try {
                // ê¸°ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const weather = await fetchWeatherData();
                
                // ê¸°ê°„ë³„ ë°ì´í„° ë¶„ì„
                const trendData = await fetchTrendData(period);
                
                // ì¶”ì„¸ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                updateTrendCharts(trendData, weather);
                
                // ì¸ì‚¬ì´íŠ¸ ìƒì„±
                generateTrendInsights(trendData, weather, period);
                
            } catch (error) {
                console.error('ì¶”ì„¸ ë¶„ì„ ì˜¤ë¥˜:', error);
                document.getElementById('trendInsights').innerHTML = '<p class="insight-item danger">ì¶”ì„¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>';
            }
        }

        async function fetchTrendData(period) {
            try {
                // ì‹¤ì œ ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                let hours;
                switch(period) {
                    case 'daily': hours = 24; break;
                    case 'weekly': hours = 168; break;
                    case 'monthly': hours = 720; break;
                    default: hours = 24;
                }

                const response = await fetch(`/api/sensor/correlation?hours=${hours}`);
                const data = await response.json();
                
                if (data.success && data.data && data.data.length > 0) {
                    // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì‹œê°„ë³„ë¡œ ê·¸ë£¹í™”
                    const groupedData = groupDataByTime(data.data, period);
                    return groupedData;
                } else {
                    console.log('ì„¼ì„œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ëª¨ì˜ ë°ì´í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.');
                    return generateMockTrendData(period);
                }
            } catch (error) {
                console.error('ì¶”ì„¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                return generateMockTrendData(period);
            }
        }

        // ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¥¼ ì‹œê°„ë³„ë¡œ ê·¸ë£¹í™”
        function groupDataByTime(sensorData, period) {
            const groupedData = {};
            const interval = period === 'daily' ? 1 : period === 'weekly' ? 6 : 24; // ì‹œê°„ ê°„ê²© (ì‹œê°„)
            
            sensorData.forEach(data => {
                const timestamp = new Date(data.timestamp);
                const hour = Math.floor(timestamp.getHours() / interval) * interval;
                const key = `${timestamp.getFullYear()}-${String(timestamp.getMonth() + 1).padStart(2, '0')}-${String(timestamp.getDate()).padStart(2, '0')} ${String(hour).padStart(2, '0')}:00`;
                
                if (!groupedData[key]) {
                    groupedData[key] = {
                        timestamp: new Date(timestamp.getFullYear(), timestamp.getMonth(), timestamp.getDate(), hour),
                        temperatures: [],
                        onRatios: [],
                        decibels: [],
                        powerConsumptions: []
                    };
                }
                
                if (data.temperature !== null) {
                    groupedData[key].temperatures.push(data.temperature);
                }
                if (data.compressor_state !== null) {
                    groupedData[key].onRatios.push(data.compressor_state);
                }
                if (data.decibel_level !== null) {
                    groupedData[key].decibels.push(data.decibel_level);
                }
                if (data.power_consumption !== null) {
                    groupedData[key].powerConsumptions.push(data.power_consumption);
                }
            });

            // í‰ê· ê°’ ê³„ì‚°
            return Object.values(groupedData).map(group => {
                const avgTemp = group.temperatures.length > 0 ? 
                    group.temperatures.reduce((sum, temp) => sum + temp, 0) / group.temperatures.length : 15;
                const avgOnRatio = group.onRatios.length > 0 ? 
                    group.onRatios.reduce((sum, ratio) => sum + ratio, 0) / group.onRatios.length : 0.5;
                const avgDecibel = group.decibels.length > 0 ? 
                    group.decibels.reduce((sum, db) => sum + db, 0) / group.decibels.length : 45;
                const avgPower = group.powerConsumptions.length > 0 ? 
                    group.powerConsumptions.reduce((sum, power) => sum + power, 0) / group.powerConsumptions.length : 100;

                return {
                    timestamp: group.timestamp,
                    temperature: avgTemp,
                    onRatio: avgOnRatio,
                    decibel: avgDecibel,
                    powerConsumption: avgPower,
                    efficiency: Math.max(0, 100 - Math.abs(avgOnRatio - (0.5 + (15 - avgTemp) * 0.02)) * 200)
                };
            }).sort((a, b) => a.timestamp - b.timestamp);
        }

        // ëª¨ì˜ ë°ì´í„° ìƒì„± (ê¸°ì¡´ ë¡œì§)
        function generateMockTrendData(period) {
            const now = new Date();
            const dataPoints = [];
            
            let hours;
            switch(period) {
                case 'daily': hours = 24; break;
                case 'weekly': hours = 168; break;
                case 'monthly': hours = 720; break;
                default: hours = 24;
            }
            
            for (let i = 0; i < hours; i += 6) { // 6ì‹œê°„ë§ˆë‹¤ ë°ì´í„° í¬ì¸íŠ¸
                const timestamp = new Date(now.getTime() - (hours - i) * 60 * 60 * 1000);
                const temperature = 15 + Math.sin(i / 24 * Math.PI * 2) * 10 + (Math.random() - 0.5) * 5;
                const onRatio = Math.max(0, Math.min(1, 0.5 + (15 - temperature) * 0.02 + (Math.random() - 0.5) * 0.2));
                
                dataPoints.push({
                    timestamp,
                    temperature,
                    onRatio,
                    efficiency: Math.max(0, 100 - Math.abs(onRatio - (0.5 + (15 - temperature) * 0.02)) * 200)
                });
            }
            
            return dataPoints;
        }

        function updateTrendCharts(trendData, weather) {
            // ì˜¨ë„ ì¶”ì„¸ ì°¨íŠ¸
            updateTemperatureTrendChart(trendData);
            
            // íš¨ìœ¨ì„± ì¶”ì„¸ ì°¨íŠ¸
            updateEfficiencyTrendChart(trendData);
        }

        function updateTemperatureTrendChart(trendData) {
            if (!charts.temperatureTrend) {
                const ctx = document.getElementById('temperatureTrendChart').getContext('2d');
                charts.temperatureTrend = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ì˜¨ë„',
                            data: [],
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            fill: true
                        }, {
                            label: 'ì‘ë™ ë¹„ìœ¨',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'ì˜¨ë„ (Â°C)'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'ì‘ë™ ë¹„ìœ¨ (%)'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                            }
                        }
                    }
                });
            }

            const labels = trendData.map(d => d.timestamp.toLocaleTimeString());
            const temperatures = trendData.map(d => d.temperature);
            const onRatios = trendData.map(d => d.onRatio * 100);

            charts.temperatureTrend.data.labels = labels;
            charts.temperatureTrend.data.datasets[0].data = temperatures;
            charts.temperatureTrend.data.datasets[1].data = onRatios;
            charts.temperatureTrend.update();
        }

        function updateEfficiencyTrendChart(trendData) {
            if (!charts.efficiencyTrend) {
                const ctx = document.getElementById('efficiencyTrendChart').getContext('2d');
                charts.efficiencyTrend = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ì—ë„ˆì§€ íš¨ìœ¨ì„±',
                            data: [],
                            borderColor: '#27ae60',
                            backgroundColor: 'rgba(39, 174, 96, 0.1)',
                            borderWidth: 3,
                            fill: true
                        }, {
                            label: 'ì˜ˆì¸¡ ì •í™•ë„',
                            data: [],
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            borderDash: [5, 5]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: 0,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'íš¨ìœ¨ì„± (%)'
                                }
                            }
                        }
                    }
                });
            }

            const labels = trendData.map(d => d.timestamp.toLocaleTimeString());
            const efficiencies = trendData.map(d => d.efficiency);
            const accuracies = trendData.map(d => Math.max(0, 100 - Math.abs(d.onRatio - (0.5 + (15 - d.temperature) * 0.02)) * 200));

            charts.efficiencyTrend.data.labels = labels;
            charts.efficiencyTrend.data.datasets[0].data = efficiencies;
            charts.efficiencyTrend.data.datasets[1].data = accuracies;
            charts.efficiencyTrend.update();
        }

        function generateTrendInsights(trendData, weather, period) {
            const insights = [];
            
            // ì˜¨ë„ ë¶„ì„
            const avgTemp = trendData.reduce((sum, d) => sum + d.temperature, 0) / trendData.length;
            const tempRange = Math.max(...trendData.map(d => d.temperature)) - Math.min(...trendData.map(d => d.temperature));
            
            if (tempRange > 15) {
                insights.push({
                    type: 'warning',
                    message: `ì˜¨ë„ ë³€í™”ê°€ í½ë‹ˆë‹¤ (${tempRange.toFixed(1)}Â°C). ì••ì¶•ê¸° ì‘ë™ íŒ¨í„´ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`
                });
            } else if (tempRange < 5) {
                insights.push({
                    type: 'success',
                    message: `ì˜¨ë„ê°€ ì•ˆì •ì ì…ë‹ˆë‹¤ (${tempRange.toFixed(1)}Â°C). ì••ì¶•ê¸° ì‘ë™ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•©ë‹ˆë‹¤.`
                });
            }

            // íš¨ìœ¨ì„± ë¶„ì„
            const avgEfficiency = trendData.reduce((sum, d) => sum + d.efficiency, 0) / trendData.length;
            if (avgEfficiency > 80) {
                insights.push({
                    type: 'success',
                    message: `ë†’ì€ ì—ë„ˆì§€ íš¨ìœ¨ì„±ì„ ë³´ì…ë‹ˆë‹¤ (${avgEfficiency.toFixed(1)}%).`
                });
            } else if (avgEfficiency < 50) {
                insights.push({
                    type: 'danger',
                    message: `ì—ë„ˆì§€ íš¨ìœ¨ì„±ì´ ë‚®ìŠµë‹ˆë‹¤ (${avgEfficiency.toFixed(1)}%). ìµœì í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤.`
                });
            }

            // ì¶”ì„¸ ë¶„ì„
            const recentEfficiency = trendData.slice(-5).reduce((sum, d) => sum + d.efficiency, 0) / 5;
            const earlyEfficiency = trendData.slice(0, 5).reduce((sum, d) => sum + d.efficiency, 0) / 5;
            
            if (recentEfficiency > earlyEfficiency + 10) {
                insights.push({
                    type: 'success',
                    message: 'íš¨ìœ¨ì„±ì´ ê°œì„ ë˜ê³  ìˆìŠµë‹ˆë‹¤. ìµœê·¼ 5ê°œ ë°ì´í„° í¬ì¸íŠ¸ì—ì„œ í–¥ìƒëœ ì„±ëŠ¥ì„ ë³´ì…ë‹ˆë‹¤.'
                });
            } else if (recentEfficiency < earlyEfficiency - 10) {
                insights.push({
                    type: 'warning',
                    message: 'íš¨ìœ¨ì„±ì´ ê°ì†Œí•˜ê³  ìˆìŠµë‹ˆë‹¤. ì‹œìŠ¤í…œ ì ê²€ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
                });
            }

            // ê³„ì ˆì  íŒ¨í„´ ë¶„ì„
            if (period === 'monthly') {
                const winterEfficiency = trendData.filter(d => d.temperature < 5).reduce((sum, d) => sum + d.efficiency, 0) / Math.max(1, trendData.filter(d => d.temperature < 5).length);
                const summerEfficiency = trendData.filter(d => d.temperature > 25).reduce((sum, d) => sum + d.efficiency, 0) / Math.max(1, trendData.filter(d => d.temperature > 25).length);
                
                if (winterEfficiency > summerEfficiency + 20) {
                    insights.push({
                        type: 'info',
                        message: 'ê²¨ìš¸ì²  íš¨ìœ¨ì„±ì´ ì—¬ë¦„ì² ë³´ë‹¤ ë†’ìŠµë‹ˆë‹¤. ê³„ì ˆë³„ ìš´ì˜ ì „ëµì„ ê³ ë ¤í•´ë³´ì„¸ìš”.'
                    });
                }
            }

            // ì¸ì‚¬ì´íŠ¸ í‘œì‹œ
            const insightsContainer = document.getElementById('trendInsights');
            if (insights.length === 0) {
                insightsContainer.innerHTML = '<p class="insight-item">íŠ¹ë³„í•œ íŒ¨í„´ì´ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>';
            } else {
                insightsContainer.innerHTML = insights.map(insight => 
                    `<div class="insight-item ${insight.type}">${insight.message}</div>`
                ).join('');
            }
        }

        function exportTrendData() {
            // ì¶”ì„¸ ë°ì´í„° ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥
            const trendData = {
                period: currentTrendPeriod,
                timestamp: new Date().toISOString(),
                data: charts.temperatureTrend ? charts.temperatureTrend.data : null
            };
            
            const dataStr = JSON.stringify(trendData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `trend_analysis_${currentTrendPeriod}_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        // ì´ìƒ ë°ì´í„° ë¶„ì„ í•¨ìˆ˜ë“¤
        let anomalyData = [];
        
        // ì ì‘í˜• ì„ê³„ê°’ ì‹œìŠ¤í…œ
        class AdaptiveThresholdSystem {
            constructor() {
                this.baseThreshold = 45.0;
                this.temperatureFactor = 0.1;
                this.timeFactor = 0.05;
                this.seasonalFactor = 0.15;
                this.failureHistory = [];
            }
            
            calculateAdaptiveThreshold(temperature, timeOfDay, season, vibrationLevel = 0, powerConsumption = 0) {
                let threshold = this.baseThreshold;
                
                // ì˜¨ë„ ë³´ì •
                if (temperature < 0) threshold -= 5.0;
                else if (temperature < 10) threshold -= 3.0;
                else if (temperature < 20) threshold += 0.0;
                else if (temperature < 30) threshold += 2.0;
                else threshold += 5.0;
                
                // ì‹œê°„ëŒ€ ë³´ì •
                if (timeOfDay >= 22 || timeOfDay <= 6) threshold -= 2.0;  // ë°¤ì‹œê°„
                else if (timeOfDay >= 7 && timeOfDay <= 9) threshold += 1.0;  // ì•„ì¹¨ ì¶œê·¼ì‹œê°„
                else if (timeOfDay >= 18 && timeOfDay <= 21) threshold += 0.5;  // ì €ë… ì‹œê°„
                
                // ê³„ì ˆ ë³´ì •
                if (season === 'winter') threshold -= 3.0;
                else if (season === 'summer') threshold += 2.0;
                
                // ì§„ë™ ë³´ì •
                if (vibrationLevel > 0.8) threshold += 3.0;
                else if (vibrationLevel > 0.5) threshold += 1.0;
                
                // ì „ë ¥ ë³´ì •
                if (powerConsumption > 150) threshold += 2.0;
                else if (powerConsumption < 50) threshold -= 1.0;
                
                // ì„ê³„ê°’ ë²”ìœ„ ì œí•œ (30dB ~ 70dB)
                return Math.max(30.0, Math.min(70.0, threshold));
            }
            
            detectFailure(decibelLevel, temperature, timeOfDay, season, vibrationLevel = 0, powerConsumption = 0, duration = 0) {
                const adaptiveThreshold = this.calculateAdaptiveThreshold(
                    temperature, timeOfDay, season, vibrationLevel, powerConsumption
                );
                
                const failureTypes = {
                    'compressor_failure': { minDb: 60, maxDb: 80, minDuration: 300 },
                    'motor_failure': { minDb: 55, maxDb: 75, minDuration: 180 },
                    'bearing_failure': { minDb: 50, maxDb: 70, minDuration: 600 },
                    'electrical_failure': { minDb: 40, maxDb: 60, minDuration: 60 }
                };
                
                for (const [type, criteria] of Object.entries(failureTypes)) {
                    if (decibelLevel >= criteria.minDb && 
                        decibelLevel <= criteria.maxDb && 
                        duration >= criteria.minDuration) {
                        
                        const confidence = Math.min(1.0, (decibelLevel - adaptiveThreshold) / 20.0);
                        
                        this.failureHistory.push({
                            timestamp: new Date().toISOString(),
                            type: type,
                            confidence: confidence,
                            decibelLevel: decibelLevel,
                            adaptiveThreshold: adaptiveThreshold,
                            temperature: temperature
                        });
                        
                        return {
                            detected: true,
                            type: type,
                            confidence: confidence,
                            adaptiveThreshold: adaptiveThreshold
                        };
                    }
                }
                
                return {
                    detected: false,
                    adaptiveThreshold: adaptiveThreshold
                };
            }
            
            getCurrentSeason() {
                const month = new Date().getMonth() + 1;
                if (month >= 12 || month <= 2) return 'winter';
                if (month >= 3 && month <= 5) return 'spring';
                if (month >= 6 && month <= 8) return 'summer';
                return 'autumn';
            }
            
            getFailureStatistics(hours = 24) {
                const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);
                const recentFailures = this.failureHistory.filter(
                    f => new Date(f.timestamp) >= cutoffTime
                );
                
                const failureTypes = {};
                recentFailures.forEach(f => {
                    failureTypes[f.type] = (failureTypes[f.type] || 0) + 1;
                });
                
                return {
                    totalFailures: recentFailures.length,
                    failureTypes: failureTypes,
                    avgConfidence: recentFailures.length > 0 ? 
                        recentFailures.reduce((sum, f) => sum + f.confidence, 0) / recentFailures.length : 0,
                    recentFailures: recentFailures.slice(-10)
                };
            }
        }
        
        // ì ì‘í˜• ì„ê³„ê°’ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
        const adaptiveThreshold = new AdaptiveThresholdSystem();

        async function showAnomalyDetails() {
            try {
                // ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/api/sensor/correlation?hours=24');
                const data = await response.json();
                
                if (!data.success || !data.data) {
                    document.getElementById('anomalyList').innerHTML = '<p>ì´ìƒ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }

                // ì´ìƒ ë°ì´í„° ë¶„ì„
                anomalyData = analyzeAnomalies(data.data);
                
                // UI ì—…ë°ì´íŠ¸
                displayAnomalies(anomalyData);
                
            } catch (error) {
                console.error('ì´ìƒ ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:', error);
                document.getElementById('anomalyList').innerHTML = '<p>ì´ìƒ ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>';
            }
        }

        function analyzeAnomalies(sensorData) {
            const anomalies = [];
            
            sensorData.forEach(item => {
                const anomaly = {
                    timestamp: new Date(item.timestamp),
                    device_id: item.device_id,
                    temperature: item.temperature,
                    decibel_level: item.decibel_level,
                    compressor_state: item.compressor_state,
                    power_consumption: item.power_consumption,
                    rms_energy: item.rms_energy,
                    types: []
                };

                // ê³ ë°ì‹œë²¨ ì´ìƒ (â‰¥60dB)
                if (item.decibel_level >= 60) {
                    anomaly.types.push('high_db');
                    anomaly.severity = 'high';
                }
                
                // ì €ì˜¨ ì´ìƒ (â‰¤5Â°C)
                if (item.temperature <= 5) {
                    anomaly.types.push('low_temp');
                    anomaly.severity = anomaly.severity || 'medium';
                }
                
                // ê³ ì˜¨ ì´ìƒ (â‰¥25Â°C)
                if (item.temperature >= 25) {
                    anomaly.types.push('high_temp');
                    anomaly.severity = anomaly.severity || 'medium';
                }
                
                // ì „ë ¥ ì´ìƒ (í‰ê·  ëŒ€ë¹„ Â±30% ì´ìƒ)
                const avgPower = sensorData.reduce((sum, d) => sum + (d.power_consumption || 0), 0) / sensorData.length;
                if (item.power_consumption && Math.abs(item.power_consumption - avgPower) / avgPower > 0.3) {
                    anomaly.types.push('power_anomaly');
                    anomaly.severity = anomaly.severity || 'low';
                }

                // ì´ìƒì´ ìˆëŠ” ê²½ìš°ë§Œ ì¶”ê°€
                if (anomaly.types.length > 0) {
                    anomalies.push(anomaly);
                }
            });

            // ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹ ìˆœ)
            return anomalies.sort((a, b) => b.timestamp - a.timestamp);
        }

        function displayAnomalies(anomalies) {
            const container = document.getElementById('anomalyList');
            
            if (anomalies.length === 0) {
                container.innerHTML = '<p>ì´ìƒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            const html = anomalies.map(anomaly => {
                const typeLabels = {
                    'high_db': 'ê³ ë°ì‹œë²¨',
                    'low_temp': 'ì €ì˜¨',
                    'high_temp': 'ê³ ì˜¨',
                    'power_anomaly': 'ì „ë ¥ì´ìƒ'
                };

                const severityColors = {
                    'high': '#e74c3c',
                    'medium': '#f39c12',
                    'low': '#3498db'
                };

                const typeClass = anomaly.types.includes('high_db') ? 'high-db' : 
                                anomaly.types.includes('low_temp') || anomaly.types.includes('high_temp') ? 'temp-anomaly' :
                                anomaly.types.includes('power_anomaly') ? 'power-anomaly' : '';

                return `
                    <div class="anomaly-item ${typeClass}">
                        <div class="anomaly-header">
                            <span class="anomaly-time">${anomaly.timestamp.toLocaleString()}</span>
                            <span class="anomaly-type" style="background-color: ${severityColors[anomaly.severity]}">
                                ${anomaly.types.map(type => typeLabels[type]).join(', ')}
                            </span>
                        </div>
                        <div class="anomaly-details">
                            <div class="anomaly-detail">
                                <span class="anomaly-detail-label">ì˜¨ë„</span>
                                <span class="anomaly-detail-value">${anomaly.temperature?.toFixed(1) || 'N/A'}Â°C</span>
                            </div>
                            <div class="anomaly-detail">
                                <span class="anomaly-detail-label">ë°ì‹œë²¨</span>
                                <span class="anomaly-detail-value">${anomaly.decibel_level?.toFixed(1) || 'N/A'}dB</span>
                            </div>
                            <div class="anomaly-detail">
                                <span class="anomaly-detail-label">ì••ì¶•ê¸°</span>
                                <span class="anomaly-detail-value">${anomaly.compressor_state ? 'ON' : 'OFF'}</span>
                            </div>
                            <div class="anomaly-detail">
                                <span class="anomaly-detail-label">ì „ë ¥</span>
                                <span class="anomaly-detail-value">${anomaly.power_consumption?.toFixed(1) || 'N/A'}W</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function clearAnomalyDetails() {
            document.getElementById('anomalyList').innerHTML = '<p>ì´ìƒ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ë ¤ë©´ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</p>';
            anomalyData = [];
        }

        function filterAnomalies() {
            const filter = document.getElementById('anomalyFilter').value;
            let filteredData = anomalyData;

            if (filter !== 'all') {
                filteredData = anomalyData.filter(anomaly => {
                    switch(filter) {
                        case 'high_db':
                            return anomaly.types.includes('high_db');
                        case 'low_temp':
                            return anomaly.types.includes('low_temp');
                        case 'high_temp':
                            return anomaly.types.includes('high_temp');
                        case 'power_anomaly':
                            return anomaly.types.includes('power_anomaly');
                        default:
                            return true;
                    }
                });
            }

            displayAnomalies(filteredData);
        }

        // ê³ ì¥ ê°ì§€ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        let failureMonitoringActive = false;
        let failureData = [];

        function startFailureMonitoring() {
            failureMonitoringActive = true;
            updateFailureStatus('active', 'ê³ ì¥ ê°ì§€ í™œì„±í™”');
            
            // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            setInterval(monitorFailures, 5000); // 5ì´ˆë§ˆë‹¤ ì²´í¬
            
            document.getElementById('failureList').innerHTML = '<p>ê³ ì¥ ê°ì§€ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¤‘...</p>';
        }

        function updateFailureStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');
            
            statusDot.className = `status-dot ${status}`;
            statusText.textContent = text;
        }

        async function monitorFailures() {
            if (!failureMonitoringActive) return;

            try {
                // ìµœê·¼ ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/api/esp32/features/recent?limit=10&hours=1');
                const data = await response.json();
                
                if (!data.success || !data.data) return;

                // ê° ë°ì´í„°ì— ëŒ€í•´ ê³ ì¥ ê°ì§€
                for (const sensorData of data.data) {
                    const currentTime = new Date();
                    const timeOfDay = currentTime.getHours();
                    const season = adaptiveThreshold.getCurrentSeason();
                    
                    const failureResult = adaptiveThreshold.detectFailure(
                        sensorData.decibel_level || 0,
                        sensorData.temperature || 20,
                        timeOfDay,
                        season,
                        sensorData.vibration_level || 0,
                        sensorData.power_consumption || 0,
                        sensorData.duration || 0
                    );

                    if (failureResult.detected) {
                        failureData.push({
                            ...failureResult,
                            sensorData: sensorData,
                            timestamp: currentTime.toISOString()
                        });
                        
                        // ê³ ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸
                        updateFailureStatus('failure', `ê³ ì¥ ê°ì§€: ${failureResult.type}`);
                        
                        // ì•Œë¦¼ í‘œì‹œ
                        showFailureAlert(failureResult);
                    }
                }

                // ì ì‘í˜• ì„ê³„ê°’ ì—…ë°ì´íŠ¸
                if (data.data.length > 0) {
                    const latestData = data.data[0];
                    const currentTime = new Date();
                    const timeOfDay = currentTime.getHours();
                    const season = adaptiveThreshold.getCurrentSeason();
                    
                    const adaptiveThresholdValue = adaptiveThreshold.calculateAdaptiveThreshold(
                        latestData.temperature || 20,
                        timeOfDay,
                        season,
                        latestData.vibration_level || 0,
                        latestData.power_consumption || 0
                    );
                    
                    document.getElementById('adaptiveThreshold').textContent = `${adaptiveThresholdValue.toFixed(1)} dB`;
                }

            } catch (error) {
                console.error('ê³ ì¥ ê°ì§€ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜:', error);
            }
        }

        function showFailureAlert(failureResult) {
            // ë¸Œë¼ìš°ì € ì•Œë¦¼
            if (Notification.permission === 'granted') {
                new Notification('ê³ ì¥ ê°ì§€!', {
                    body: `${failureResult.type} ê°ì§€ë¨ (ì‹ ë¢°ë„: ${(failureResult.confidence * 100).toFixed(1)}%)`,
                    icon: '/favicon.ico'
                });
            }
            
            // í™”ë©´ ì•Œë¦¼
            const alertDiv = document.createElement('div');
            alertDiv.className = 'failure-alert';
            alertDiv.innerHTML = `
                <div class="alert-content">
                    <h4>ğŸš¨ ê³ ì¥ ê°ì§€!</h4>
                    <p>ìœ í˜•: ${failureResult.type}</p>
                    <p>ì‹ ë¢°ë„: ${(failureResult.confidence * 100).toFixed(1)}%</p>
                    <p>ì ì‘í˜• ì„ê³„ê°’: ${failureResult.adaptiveThreshold.toFixed(1)} dB</p>
                </div>
            `;
            
            document.body.appendChild(alertDiv);
            
            // 5ì´ˆ í›„ ìë™ ì œê±°
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 5000);
        }

        function showFailureDetails() {
            const stats = adaptiveThreshold.getFailureStatistics(24);
            displayFailures(stats.recentFailures);
        }

        function displayFailures(failures) {
            const container = document.getElementById('failureList');
            
            if (failures.length === 0) {
                container.innerHTML = '<p>ìµœê·¼ 24ì‹œê°„ ë™ì•ˆ ê°ì§€ëœ ê³ ì¥ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            const typeLabels = {
                'compressor_failure': 'ì••ì¶•ê¸° ê³ ì¥',
                'motor_failure': 'ëª¨í„° ê³ ì¥',
                'bearing_failure': 'ë² ì–´ë§ ê³ ì¥',
                'electrical_failure': 'ì „ê¸° ê³ ì¥'
            };

            const html = failures.map(failure => {
                const failureTime = new Date(failure.timestamp);
                const typeClass = failure.type.replace('_', '-');
                
                return `
                    <div class="failure-item ${typeClass}">
                        <div class="failure-header">
                            <span class="failure-time">${failureTime.toLocaleString()}</span>
                            <span class="failure-type">${typeLabels[failure.type] || failure.type}</span>
                        </div>
                        <div class="failure-details">
                            <div class="failure-detail">
                                <span class="failure-detail-label">ë°ì‹œë²¨</span>
                                <span class="failure-detail-value">${failure.decibelLevel.toFixed(1)} dB</span>
                            </div>
                            <div class="failure-detail">
                                <span class="failure-detail-label">ì„ê³„ê°’</span>
                                <span class="failure-detail-value">${failure.adaptiveThreshold.toFixed(1)} dB</span>
                            </div>
                            <div class="failure-detail">
                                <span class="failure-detail-label">ì˜¨ë„</span>
                                <span class="failure-detail-value">${failure.temperature.toFixed(1)}Â°C</span>
                            </div>
                            <div class="failure-detail">
                                <span class="failure-detail-label">ì‹ ë¢°ë„</span>
                                <span class="failure-detail-value">${(failure.confidence * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${failure.confidence * 100}%"></div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function filterFailures() {
            const filter = document.getElementById('failureFilter').value;
            const stats = adaptiveThreshold.getFailureStatistics(24);
            let filteredFailures = stats.recentFailures;

            if (filter !== 'all') {
                filteredFailures = stats.recentFailures.filter(failure => failure.type === filter);
            }

            displayFailures(filteredFailures);
        }

        function exportFailureReport() {
            const stats = adaptiveThreshold.getFailureStatistics(24);
            const report = {
                generated_at: new Date().toISOString(),
                failure_statistics: stats,
                adaptive_threshold_config: {
                    base_threshold: adaptiveThreshold.baseThreshold,
                    temperature_factor: adaptiveThreshold.temperatureFactor,
                    time_factor: adaptiveThreshold.timeFactor,
                    seasonal_factor: adaptiveThreshold.seasonalFactor
                }
            };
            
            const dataStr = JSON.stringify(report, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `failure_report_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        // ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
        if (Notification.permission === 'default') {
            Notification.requestPermission();
        }

        // ë§¥ë½ ê¸°ë°˜ í•™ìŠµ ì‹œìŠ¤í…œ
        let contextualLearningActive = false;
        let learningData = [];
        let learningProgress = 0;
        let learningInterval = null;
        let learningStatistics = {
            totalWindows: 0,
            patternCounts: {},
            failureTypeCounts: {},
            avgConfidence: 0,
            learningStartTime: null,
            lastLearningTime: null
        };

        class ContextualLearningSystem {
            constructor() {
                this.windowSizes = [60, 300, 900, 3600]; // 1ë¶„, 5ë¶„, 15ë¶„, 1ì‹œê°„
                this.timeSeriesBuffer = [];
                this.contextBuffer = [];
                this.learningResults = [];
                this.minConfidence = 0.6;
                this.learningPeriod = 24; // ì‹œê°„
            }

            // ì‹œê³„ì—´ ìœˆë„ìš° ìƒì„±
            createTimeSeriesWindow(windowSize, data) {
                if (data.length < 10) return null;

                const windowData = data.slice(-windowSize);
                const startTime = new Date(windowData[0].timestamp);
                const endTime = new Date(windowData[windowData.length - 1].timestamp);

                return {
                    data: windowData,
                    startTime: startTime,
                    endTime: endTime,
                    windowSize: windowSize,
                    context: this.getContextForWindow(startTime, endTime)
                };
            }

            // ë§¥ë½ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            getContextForWindow(startTime, endTime) {
                const relevantContexts = this.contextBuffer.filter(ctx => {
                    const ctxTime = new Date(ctx.timestamp);
                    return ctxTime >= startTime && ctxTime <= endTime;
                });

                if (relevantContexts.length === 0) {
                    return this.contextBuffer.length > 0 ? this.contextBuffer[this.contextBuffer.length - 1].context : {};
                }

                // ì»¨í…ìŠ¤íŠ¸ í†µí•©
                const mergedContext = {};
                relevantContexts.forEach(ctx => {
                    Object.assign(mergedContext, ctx.context);
                });

                return mergedContext;
            }

            // ë§¥ë½ì  íŠ¹ì§• ì¶”ì¶œ
            extractContextualFeatures(window) {
                if (!window || !window.data) return {};

                const decibelValues = window.data.map(d => d.decibel_level || 0);
                const temperatureValues = window.data.map(d => d.temperature || 20);
                const compressorStates = window.data.map(d => d.compressor_state || 0);

                // ê¸°ë³¸ í†µê³„ íŠ¹ì§•
                const features = {
                    windowSize: window.windowSize,
                    dataCount: window.data.length,
                    durationSeconds: (window.endTime - window.startTime) / 1000,

                    // ë°ì‹œë²¨ íŠ¹ì§•
                    decibelMean: this.calculateMean(decibelValues),
                    decibelStd: this.calculateStd(decibelValues),
                    decibelMin: Math.min(...decibelValues),
                    decibelMax: Math.max(...decibelValues),
                    decibelRange: Math.max(...decibelValues) - Math.min(...decibelValues),

                    // ì˜¨ë„ íŠ¹ì§•
                    temperatureMean: this.calculateMean(temperatureValues),
                    temperatureStd: this.calculateStd(temperatureValues),
                    temperatureTrend: this.calculateTrend(temperatureValues),

                    // ì••ì¶•ê¸° ìƒíƒœ íŠ¹ì§•
                    compressorOnRatio: this.calculateMean(compressorStates),
                    compressorCycles: this.countCycles(compressorStates),
                    compressorAvgCycleLength: this.calculateAvgCycleLength(compressorStates),

                    // ì‹œê³„ì—´ íŒ¨í„´ íŠ¹ì§•
                    trendSlope: this.calculateTrend(decibelValues),
                    volatility: this.calculateVolatility(decibelValues),
                    autocorrelation: this.calculateAutocorrelation(decibelValues),
                    periodicity: this.calculatePeriodicity(decibelValues),

                    // ê³ ì¥ ê´€ë ¨ íŠ¹ì§•
                    highDecibelRatio: this.calculateMean(decibelValues.map(db => db > 60 ? 1 : 0)),
                    extremeValuesCount: decibelValues.filter(db => db > 70 || db < 30).length,
                    stabilityScore: this.calculateStabilityScore(decibelValues)
                };

                return features;
            }

            // íŒ¨í„´ ë¶„ë¥˜
            classifyPattern(features, context) {
                // ì ì§„ì  ì„±ëŠ¥ ì €í•˜
                if (features.trendSlope > 0.1 && features.stabilityScore > 0.7 && features.decibelMean > 50) {
                    return {
                        patternType: 'gradual_degradation',
                        failureType: 'bearing_wear',
                        confidence: 0.8
                    };
                }

                // ê¸‰ê²©í•œ ê³ ì¥
                if (features.volatility > 0.3 && features.extremeValuesCount > 5) {
                    return {
                        patternType: 'sudden_failure',
                        failureType: 'electrical_fault',
                        confidence: 0.9
                    };
                }

                // ê°„í—ì  ê³ ì¥
                if (features.compressorCycles > 10 && features.stabilityScore < 0.5) {
                    return {
                        patternType: 'intermittent_failure',
                        failureType: 'mechanical_looseness',
                        confidence: 0.7
                    };
                }

                // ê³ ì˜¨ í™˜ê²½ì—ì„œì˜ ì„±ëŠ¥ ì €í•˜
                if (features.temperatureMean > 30 && features.decibelMean > 55) {
                    return {
                        patternType: 'thermal_stress',
                        failureType: 'compressor_fatigue',
                        confidence: 0.6
                    };
                }

                // ì •ìƒ ìš´ì˜
                return {
                    patternType: 'normal_operation',
                    failureType: 'normal',
                    confidence: 0.5
                };
            }

            // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
            calculateMean(values) {
                return values.reduce((sum, val) => sum + val, 0) / values.length;
            }

            calculateStd(values) {
                const mean = this.calculateMean(values);
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                return Math.sqrt(variance);
            }

            calculateTrend(values) {
                if (values.length < 2) return 0;
                const x = Array.from({length: values.length}, (_, i) => i);
                const n = values.length;
                const sumX = x.reduce((sum, val) => sum + val, 0);
                const sumY = values.reduce((sum, val) => sum + val, 0);
                const sumXY = x.reduce((sum, val, i) => sum + val * values[i], 0);
                const sumXX = x.reduce((sum, val) => sum + val * val, 0);
                
                return (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            }

            calculateVolatility(values) {
                if (values.length < 2) return 0;
                const diffs = [];
                for (let i = 1; i < values.length; i++) {
                    diffs.push(values[i] - values[i-1]);
                }
                return this.calculateStd(diffs);
            }

            calculateAutocorrelation(values) {
                if (values.length < 10) return 0;
                try {
                    const mean = this.calculateMean(values);
                    const numerator = values.slice(0, -1).reduce((sum, val, i) => 
                        sum + (val - mean) * (values[i + 1] - mean), 0);
                    const denominator = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
                    return denominator === 0 ? 0 : numerator / denominator;
                } catch {
                    return 0;
                }
            }

            calculatePeriodicity(values) {
                if (values.length < 10) return 0;
                
                try {
                    // ì‹¤ì œ FFTë¥¼ ì‚¬ìš©í•œ ì£¼ê¸°ì„± ê³„ì‚°
                    const fft = this.simpleFFT(values);
                    const freqs = Array.from({length: values.length}, (_, i) => i / values.length);
                    
                    // ì£¼ìš” ì£¼íŒŒìˆ˜ ì„±ë¶„ ì°¾ê¸°
                    let maxPower = 0;
                    let dominantFreq = 0;
                    
                    for (let i = 1; i < fft.length / 2; i++) {
                        const power = Math.abs(fft[i]) ** 2;
                        if (power > maxPower) {
                            maxPower = power;
                            dominantFreq = freqs[i];
                        }
                    }
                    
                    return dominantFreq;
                } catch {
                    return 0;
                }
            }

            simpleFFT(values) {
                // ê°„ë‹¨í•œ FFT êµ¬í˜„ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê¶Œì¥)
                const N = values.length;
                const result = new Array(N);
                
                for (let k = 0; k < N; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += values[n] * Math.cos(angle);
                        imag += values[n] * Math.sin(angle);
                    }
                    
                    result[k] = real + imag * 1i;
                }
                
                return result;
            }

            countCycles(states) {
                if (states.length < 2) return 0;
                let cycles = 0;
                let prevState = states[0];
                
                for (let i = 1; i < states.length; i++) {
                    if (prevState === 0 && states[i] === 1) {
                        cycles++;
                    }
                    prevState = states[i];
                }
                
                return cycles;
            }

            calculateAvgCycleLength(states) {
                const cycles = this.countCycles(states);
                return cycles > 0 ? states.length / cycles : 0;
            }

            calculateStabilityScore(values) {
                if (values.length < 2) return 1;
                const mean = this.calculateMean(values);
                const std = this.calculateStd(values);
                if (mean === 0) return 1;
                const cv = std / mean;
                return 1 / (1 + cv);
            }
        }

        // ë§¥ë½ ê¸°ë°˜ í•™ìŠµ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
        const contextualLearning = new ContextualLearningSystem();

        // ì‹¤ì œ ë°ì´í„° ê¸°ë°˜ í•™ìŠµ í•¨ìˆ˜ë“¤
        async function startContextualLearning() {
            if (contextualLearningActive) {
                alert('ì´ë¯¸ í•™ìŠµì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.');
                return;
            }

            contextualLearningActive = true;
            learningStatistics.learningStartTime = new Date();
            updateLearningStatus('active', 'ì‹¤ì‹œê°„ í•™ìŠµ ì§„í–‰ ì¤‘...');
            
            // ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
            const learningPeriod = parseInt(document.getElementById('learningPeriod').value);
            const windowSize = parseInt(document.getElementById('windowSize').value);
            const minConfidence = parseInt(document.getElementById('minConfidence').value) / 100;
            
            contextualLearning.learningPeriod = learningPeriod;
            contextualLearning.minConfidence = minConfidence;
            
            try {
                // ì‹¤ì‹œê°„ í•™ìŠµ ì‹œì‘
                await performInitialLearning(learningPeriod, windowSize);
                
                // ì£¼ê¸°ì  í•™ìŠµ ì„¤ì • (5ë¶„ë§ˆë‹¤)
                learningInterval = setInterval(async () => {
                    await performIncrementalLearning(windowSize);
                }, 300000); // 5ë¶„
                
                updateLearningStatus('active', `ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ (${learningPeriod}ì‹œê°„ ë°ì´í„°)`);
                
            } catch (error) {
                console.error('í•™ìŠµ ì‹œì‘ ì˜¤ë¥˜:', error);
                updateLearningStatus('error', 'í•™ìŠµ ì‹œì‘ ì‹¤íŒ¨');
                contextualLearningActive = false;
            }
        }

        async function performInitialLearning(period, windowSize) {
            try {
                // ì‹¤ì œ ì„¼ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch(`/api/esp32/features/recent?limit=1000&hours=${period}`);
                const data = await response.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    throw new Error('í•™ìŠµí•  ì„¼ì„œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                }

                console.log(`[í•™ìŠµ] ${data.data.length}ê°œì˜ ì‹¤ì œ ì„¼ì„œ ë°ì´í„°ë¡œ í•™ìŠµ ì‹œì‘`);

                // ì‹œê³„ì—´ ìœˆë„ìš° ìƒì„±
                const windows = [];
                const selectedWindowSize = windowSize;
                
                // ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ ì—¬ëŸ¬ ìœˆë„ìš° ìƒì„±
                for (let i = selectedWindowSize; i < data.data.length; i += Math.floor(selectedWindowSize / 2)) {
                    const windowData = data.data.slice(i - selectedWindowSize, i);
                    const window = contextualLearning.createTimeSeriesWindow(selectedWindowSize, windowData);
                    if (window) {
                        windows.push(window);
                    }
                }

                console.log(`[í•™ìŠµ] ${windows.length}ê°œì˜ ìœˆë„ìš° ìƒì„±`);

                // ê° ìœˆë„ìš° ë¶„ì„
                learningData = [];
                for (let i = 0; i < windows.length; i++) {
                    const window = windows[i];
                    
                    // ì‹¤ì œ íŠ¹ì§• ì¶”ì¶œ
                    const features = contextualLearning.extractContextualFeatures(window);
                    
                    // ì‹¤ì œ íŒ¨í„´ ë¶„ë¥˜
                    const classification = contextualLearning.classifyPattern(features, window.context);
                    
                    // ì‹ ë¢°ë„ í•„í„°ë§
                    if (classification.confidence >= contextualLearning.minConfidence) {
                        const learningItem = {
                            windowId: `${window.startTime.toISOString().split('T')[0]}_${window.windowSize}_${i}`,
                            timestamp: window.startTime.toISOString(),
                            patternType: classification.patternType,
                            failureType: classification.failureType,
                            confidence: classification.confidence,
                            features: features,
                            context: window.context,
                            windowSize: window.windowSize,
                            dataCount: window.data.length
                        };
                        
                        learningData.push(learningItem);
                        
                        // í†µê³„ ì—…ë°ì´íŠ¸
                        updateLearningStatistics(learningItem);
                    }
                    
                    // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                    learningProgress = ((i + 1) / windows.length) * 100;
                    updateLearningProgress(learningProgress);
                }

                console.log(`[í•™ìŠµ] ${learningData.length}ê°œì˜ íŒ¨í„´ í•™ìŠµ ì™„ë£Œ`);
                
                // í•™ìŠµ ê²°ê³¼ í‘œì‹œ
                displayLearningResults(learningData);
                updateLearningStatus('completed', `ì´ˆê¸° í•™ìŠµ ì™„ë£Œ (${learningData.length}ê°œ íŒ¨í„´)`);
                
            } catch (error) {
                console.error('ì´ˆê¸° í•™ìŠµ ì˜¤ë¥˜:', error);
                throw error;
            }
        }

        async function performIncrementalLearning(windowSize) {
            try {
                // ìµœê·¼ ë°ì´í„°ë§Œ ê°€ì ¸ì˜¤ê¸° (1ì‹œê°„)
                const response = await fetch('/api/esp32/features/recent?limit=100&hours=1');
                const data = await response.json();
                
                if (!data.success || !data.data || data.data.length === 0) {
                    return;
                }

                // ìƒˆë¡œìš´ ìœˆë„ìš° ìƒì„±
                const window = contextualLearning.createTimeSeriesWindow(windowSize, data.data);
                if (!window) return;

                // íŠ¹ì§• ì¶”ì¶œ ë° ë¶„ë¥˜
                const features = contextualLearning.extractContextualFeatures(window);
                const classification = contextualLearning.classifyPattern(features, window.context);

                // ì‹ ë¢°ë„ í•„í„°ë§
                if (classification.confidence >= contextualLearning.minConfidence) {
                    const learningItem = {
                        windowId: `incremental_${Date.now()}`,
                        timestamp: window.startTime.toISOString(),
                        patternType: classification.patternType,
                        failureType: classification.failureType,
                        confidence: classification.confidence,
                        features: features,
                        context: window.context,
                        windowSize: window.windowSize,
                        dataCount: window.data.length
                    };
                    
                    learningData.unshift(learningItem); // ìµœì‹  ë°ì´í„°ë¥¼ ì•ì— ì¶”ê°€
                    
                    // ìµœëŒ€ 1000ê°œ ìœ ì§€
                    if (learningData.length > 1000) {
                        learningData = learningData.slice(0, 1000);
                    }
                    
                    // í†µê³„ ì—…ë°ì´íŠ¸
                    updateLearningStatistics(learningItem);
                    
                    // ì‹¤ì‹œê°„ ê²°ê³¼ ì—…ë°ì´íŠ¸
                    displayLearningResults(learningData.slice(0, 50)); // ìµœê·¼ 50ê°œë§Œ í‘œì‹œ
                    
                    console.log(`[ì¦ë¶„í•™ìŠµ] ìƒˆë¡œìš´ íŒ¨í„´ í•™ìŠµ: ${classification.patternType} (${(classification.confidence * 100).toFixed(1)}%)`);
                }
                
                learningStatistics.lastLearningTime = new Date();
                
            } catch (error) {
                console.error('ì¦ë¶„ í•™ìŠµ ì˜¤ë¥˜:', error);
            }
        }

        function pauseLearning() {
            if (learningInterval) {
                clearInterval(learningInterval);
                learningInterval = null;
            }
            contextualLearningActive = false;
            updateLearningStatus('paused', 'í•™ìŠµ ì¼ì‹œì •ì§€ë¨');
        }

        function updateLearningStatistics(item) {
            learningStatistics.totalWindows++;
            
            // íŒ¨í„´ ìœ í˜•ë³„ ì¹´ìš´íŠ¸
            if (!learningStatistics.patternCounts[item.patternType]) {
                learningStatistics.patternCounts[item.patternType] = 0;
            }
            learningStatistics.patternCounts[item.patternType]++;
            
            // ê³ ì¥ ìœ í˜•ë³„ ì¹´ìš´íŠ¸
            if (!learningStatistics.failureTypeCounts[item.failureType]) {
                learningStatistics.failureTypeCounts[item.failureType] = 0;
            }
            learningStatistics.failureTypeCounts[item.failureType]++;
            
            // í‰ê·  ì‹ ë¢°ë„ ê³„ì‚°
            const totalConfidence = learningData.reduce((sum, item) => sum + item.confidence, 0);
            learningStatistics.avgConfidence = totalConfidence / learningData.length;
        }

        function updateConfidenceDisplay() {
            const slider = document.getElementById('minConfidence');
            const display = document.getElementById('confidenceDisplay');
            display.textContent = slider.value + '%';
        }

        function updateLearningStatus(status, text) {
            const statusDot = document.getElementById('learningStatus');
            const statusText = document.getElementById('learningStatusText');
            
            statusDot.className = `status-dot ${status}`;
            statusText.textContent = text;
        }

        function updateLearningProgress(progress) {
            const progressFill = document.getElementById('learningProgress');
            const progressText = document.getElementById('learningProgressText');
            
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;
        }

        function showLearningResults() {
            if (learningData.length === 0) {
                document.getElementById('learningResults').innerHTML = '<p>í•™ìŠµ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í•™ìŠµì„ ì‹œì‘í•˜ì„¸ìš”.</p>';
                return;
            }
            
            displayLearningResults(learningData);
        }

        function displayLearningResults(data) {
            const container = document.getElementById('learningResults');
            
            if (data.length === 0) {
                container.innerHTML = '<p>í•™ìŠµ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            const patternLabels = {
                'gradual_degradation': 'ì ì§„ì  ì„±ëŠ¥ ì €í•˜',
                'sudden_failure': 'ê¸‰ê²©í•œ ê³ ì¥',
                'intermittent_failure': 'ê°„í—ì  ê³ ì¥',
                'cascade_failure': 'ê³„ë‹¨ì‹ ê³ ì¥',
                'thermal_stress': 'ì—´ ì‘ë ¥',
                'normal_operation': 'ì •ìƒ ìš´ì˜'
            };

            const failureLabels = {
                'bearing_wear': 'ë² ì–´ë§ ë§ˆëª¨',
                'electrical_fault': 'ì „ê¸° ê³ ì¥',
                'mechanical_looseness': 'ê¸°ê³„ì  ëŠìŠ¨í•¨',
                'compressor_fatigue': 'ì••ì¶•ê¸° í”¼ë¡œ',
                'normal': 'ì •ìƒ'
            };

            const html = data.map(item => {
                const itemTime = new Date(item.timestamp);
                const patternClass = item.patternType.replace('_', '-');
                
                return `
                    <div class="learning-item ${patternClass}">
                        <div class="learning-header">
                            <span class="learning-time">${itemTime.toLocaleString()}</span>
                            <span class="learning-pattern">${patternLabels[item.patternType] || item.patternType}</span>
                        </div>
                        <div class="learning-details">
                            <div class="learning-detail">
                                <span class="learning-detail-label">ê³ ì¥ ìœ í˜•</span>
                                <span class="learning-detail-value">${failureLabels[item.failureType] || item.failureType}</span>
                            </div>
                            <div class="learning-detail">
                                <span class="learning-detail-label">ì‹ ë¢°ë„</span>
                                <span class="learning-detail-value">${(item.confidence * 100).toFixed(1)}%</span>
                            </div>
                            <div class="learning-detail">
                                <span class="learning-detail-label">ìœˆë„ìš° í¬ê¸°</span>
                                <span class="learning-detail-value">${item.windowSize}ì´ˆ</span>
                            </div>
                            <div class="learning-detail">
                                <span class="learning-detail-label">ë°ì´í„° ìˆ˜</span>
                                <span class="learning-detail-value">${item.features.dataCount}ê°œ</span>
                            </div>
                        </div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${item.confidence * 100}%"></div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function showLearningStatistics() {
            const stats = {
                totalWindows: learningStatistics.totalWindows,
                patternCounts: learningStatistics.patternCounts,
                failureTypeCounts: learningStatistics.failureTypeCounts,
                avgConfidence: learningStatistics.avgConfidence,
                learningStartTime: learningStatistics.learningStartTime,
                lastLearningTime: learningStatistics.lastLearningTime,
                currentDataCount: learningData.length
            };

            const statsHtml = `
                <div class="learning-statistics">
                    <h4>ğŸ“Š í•™ìŠµ í†µê³„</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-label">ì´ ìœˆë„ìš° ìˆ˜:</span>
                            <span class="stat-value">${stats.totalWindows}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">í˜„ì¬ ë°ì´í„° ìˆ˜:</span>
                            <span class="stat-value">${stats.currentDataCount}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">í‰ê·  ì‹ ë¢°ë„:</span>
                            <span class="stat-value">${(stats.avgConfidence * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">í•™ìŠµ ì‹œì‘:</span>
                            <span class="stat-value">${stats.learningStartTime ? stats.learningStartTime.toLocaleString() : 'N/A'}</span>
                        </div>
                    </div>
                    <div class="pattern-breakdown">
                        <h5>íŒ¨í„´ ìœ í˜•ë³„ ë¶„í¬:</h5>
                        ${Object.entries(stats.patternCounts).map(([pattern, count]) => 
                            `<div class="pattern-item">${pattern}: ${count}ê°œ</div>`
                        ).join('')}
                    </div>
                    <div class="failure-breakdown">
                        <h5>ê³ ì¥ ìœ í˜•ë³„ ë¶„í¬:</h5>
                        ${Object.entries(stats.failureTypeCounts).map(([failure, count]) => 
                            `<div class="failure-item">${failure}: ${count}ê°œ</div>`
                        ).join('')}
                    </div>
                </div>
            `;

            document.getElementById('learningResults').innerHTML = statsHtml;
        }

        function filterLearningResults() {
            const patternFilter = document.getElementById('learningFilter').value;
            const failureFilter = document.getElementById('failureTypeFilter').value;
            let filteredData = learningData;

            // íŒ¨í„´ ìœ í˜• í•„í„°ë§
            if (patternFilter !== 'all') {
                filteredData = filteredData.filter(item => item.patternType === patternFilter);
            }

            // ê³ ì¥ ìœ í˜• í•„í„°ë§
            if (failureFilter !== 'all') {
                filteredData = filteredData.filter(item => item.failureType === failureFilter);
            }

            displayLearningResults(filteredData);
        }

        function exportLearningData() {
            if (learningData.length === 0) {
                alert('ë‚´ë³´ë‚¼ í•™ìŠµ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const exportData = {
                exported_at: new Date().toISOString(),
                total_items: learningData.length,
                learning_data: learningData
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `contextual_learning_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateCharts(data) {
            // 45dB ê¸°ì¤€ìœ¼ë¡œ ì••ì¶•ê¸° ìƒíƒœ ê³„ì‚°
            const compressor = data.map(d => rmsToDecibel(d.rms_energy) >= 45 ? 1 : 0);
            const rms = data.map(d => d.rms_energy);
            const anomaly = data.map(d => d.anomaly_score);
            const decibel = data.map(d => rmsToDecibel(d.rms_energy));

            // ìµœê·¼ 50ê°œ ë°ì´í„°ë§Œ í‘œì‹œ
            const limit = Math.min(50, data.length);
            const recentData = {
                labels: Array.from({length: limit}, (_, i) => i + 1), // ì¸ë±ìŠ¤ ê¸°ë°˜ ë¼ë²¨
                compressor: compressor.slice(0, limit),
                rms: rms.slice(0, limit),
                anomaly: anomaly.slice(0, limit),
                decibel: decibel.slice(0, limit)
            };

            // ì••ì¶•ê¸° ìƒíƒœ ë¶„ì„ (ë°ì‹œë²¨ ê¸°ë°˜)
            updateCompressorAnalysis(data);

            // ì••ì¶•ê¸° ì‘ë™ íŒ¨í„´ ë¶„ì„
            analyzeCompressorPattern(data);

            // ê° ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            if (charts.compressor) {
                charts.compressor.data.labels = recentData.labels;
                charts.compressor.data.datasets[0].data = recentData.compressor;
                charts.compressor.update();
            }

            if (charts.rms) {
                charts.rms.data.labels = recentData.labels;
                charts.rms.data.datasets[0].data = recentData.rms;
                charts.rms.update();
            }

            if (charts.anomaly) {
                charts.anomaly.data.labels = recentData.labels;
                charts.anomaly.data.datasets[0].data = recentData.anomaly;
                charts.anomaly.update();
            }

            if (charts.decibel) {
                charts.decibel.data.labels = recentData.labels;
                charts.decibel.data.datasets[0].data = recentData.decibel;
                charts.decibel.update();
            }
        }

        // ìµœê·¼ ë°ì´í„° í…Œì´ë¸” ì—…ë°ì´íŠ¸
        function updateRecentDataTable(data) {
            const soundTypeNames = ['ì •ì ', 'ì••ì¶•ê¸°', 'íŒ¬', 'ì´ìƒìŒ', 'ê¸°íƒ€'];
            
            const table = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>ì‹œê°„</th>
                            <th>ë””ë°”ì´ìŠ¤</th>
                            <th>RMS</th>
                            <th>ë°ì‹œë²¨</th>
                            <th>ì••ì¶•ê¸°</th>
                            <th>ì´ìƒì ìˆ˜</th>
                            <th>íš¨ìœ¨ì„±</th>
                            <th>ì†Œë¦¬ìœ í˜•</th>
                            <th>ê°•ë„</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.slice(0, 10).map(item => {
                            const soundType = item.sound_type || 0;
                            const soundTypeName = soundTypeNames[Math.round(soundType)] || 'ì•Œ ìˆ˜ ì—†ìŒ';
                            const intensity = ((item.intensity_level || 0) * 100).toFixed(1);
                            
                            return `
                                <tr>
                                    <td>${new Date(item.received_at).toLocaleTimeString()}</td>
                                    <td>${item.device_id}</td>
                                    <td>${item.rms_energy.toFixed(2)}</td>
                                    <td>${rmsToDecibel(item.rms_energy).toFixed(1)} dB</td>
                                    <td>${rmsToDecibel(item.rms_energy) >= 45 ? 'ON' : 'OFF'}</td>
                                    <td>${item.anomaly_score.toFixed(3)}</td>
                                    <td>${item.efficiency_score.toFixed(3)}</td>
                                    <td>${soundTypeName}</td>
                                    <td>${intensity}%</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
            document.getElementById('recentData').innerHTML = table;
        }

        // ì•Œë¦¼ ì²´í¬
        function checkAlerts(data) {
            const alerts = [];

            if (data.anomaly_score > 0.7) {
                alerts.push({
                    type: 'danger',
                    message: `ë†’ì€ ì´ìƒ ì ìˆ˜ ê°ì§€: ${data.anomaly_score.toFixed(3)}`
                });
            }

            if (data.rms_energy > 5000) {
                alerts.push({
                    type: 'warning',
                    message: `ë†’ì€ ì†ŒìŒ ë ˆë²¨: ${data.rms_energy.toFixed(2)}`
                });
            }

            if (data.efficiency_score < 0.3) {
                alerts.push({
                    type: 'warning',
                    message: `ë‚®ì€ íš¨ìœ¨ì„±: ${data.efficiency_score.toFixed(3)}`
                });
            }

            if (rmsToDecibel(data.rms_energy) > 80) {
                alerts.push({
                    type: 'warning',
                    message: `ë†’ì€ ë°ì‹œë²¨ ë ˆë²¨: ${rmsToDecibel(data.rms_energy).toFixed(1)} dB`
                });
            }

            if (alerts.length === 0) {
                alerts.push({
                    type: 'success',
                    message: 'ëª¨ë“  ì‹œìŠ¤í…œ ì •ìƒ ì‘ë™ ì¤‘'
                });
            }

            displayAlerts(alerts);
        }

        // ì•Œë¦¼ í‘œì‹œ
        function displayAlerts(alerts) {
            const alertsContainer = document.getElementById('alerts');
            alertsContainer.innerHTML = alerts.map(alert => 
                `<div class="alert alert-${alert.type}">${alert.message}</div>`
            ).join('');
        }

        // ì•Œë¦¼ í‘œì‹œ (ì¼ë°˜)
        function showAlert(message, type) {
            const alertsContainer = document.getElementById('alerts');
            alertsContainer.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            
            // 5ì´ˆ í›„ ìë™ ì œê±°
            setTimeout(() => {
                alertsContainer.innerHTML = '';
            }, 5000);
        }

        // ìë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            autoRefreshInterval = setInterval(refreshData, 5000); // 5ì´ˆë§ˆë‹¤
            showAlert('ìë™ ìƒˆë¡œê³ ì¹¨ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        }

        // ìë™ ìƒˆë¡œê³ ì¹¨ ì¤‘ì§€
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                showAlert('ìë™ ìƒˆë¡œê³ ì¹¨ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.', 'warning');
            }
        }

        // ì„¼ì„œ ëª©ë¡ ë¡œë“œ
        async function loadSensorList() {
            try {
                const response = await fetch('/api/sensor/recent?limit=1');
                const data = await response.json();
                
                if (data.success && data.data.length > 0) {
                    const sensors = [...new Set(data.data.map(item => item.device_id))];
                    const sensorSelect = document.getElementById('sensorSelect');
                    
                    // ê¸°ì¡´ ì˜µì…˜ ì œê±° (ì „ì²´ ì„¼ì„œ ì œì™¸)
                    while (sensorSelect.children.length > 1) {
                        sensorSelect.removeChild(sensorSelect.lastChild);
                    }
                    
                    // ì„¼ì„œ ì˜µì…˜ ì¶”ê°€
                    sensors.forEach(sensor => {
                        const option = document.createElement('option');
                        option.value = sensor;
                        option.textContent = sensor;
                        sensorSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('ì„¼ì„œ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
            }
        }

        // ì„¼ì„œ ë³€ê²½
        function changeSensor() {
            loadData();
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            loadSensorList();
            refreshData();
            startAutoRefresh();
        });
    </script>
</body>
</html>
