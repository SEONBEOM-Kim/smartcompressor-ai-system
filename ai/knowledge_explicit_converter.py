#!/usr/bin/env python3
"""
Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏãúÏä§ÌÖú
Í∏∞Í≥Ñ ÏÑ§Ïπò Ï†ÑÏóê ÏóîÏßÄÎãàÏñ¥Ïùò ÏïîÎ¨µÏ†Å ÏßÄÏãùÏùÑ Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°ú ÌôòÏÇ∞ÌïòÏó¨ AI ÌïôÏäµÏóê ÌôúÏö©
"""

import numpy as np
import json
import os
from typing import Dict, List, Tuple, Optional
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class KnowledgeExplicitConverter:
    """Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.explicit_knowledge = {}
        self.knowledge_rules = {}
        self.synthetic_data_generator = {}
        self.ai_learning_system = {}
        
        print("üß† Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî")
        print("   Í∏∞Í≥Ñ ÏÑ§Ïπò Ï†Ñ AI ÌïôÏäµÏùÑ ÏúÑÌïú ÏßÄÏãù ÌôòÏÇ∞ ÏãúÏä§ÌÖú")
    
    def convert_implicit_to_explicit_knowledge(self, engineer_interviews: List[Dict]):
        """ÏïîÎ¨µÏ†Å ÏßÄÏãùÏùÑ Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°ú ÌôòÏÇ∞"""
        try:
            print("üîÑ ÏïîÎ¨µÏ†Å ÏßÄÏãù ‚Üí Î™ÖÏãúÏ†Å ÏßÄÏãù ÌôòÏÇ∞ ÏãúÏûë")
            
            # 1. Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
            analyzed_knowledge = self._analyze_engineer_interviews(engineer_interviews)
            
            # 2. ÏßÄÏãù Íµ¨Ï°∞Ìôî
            structured_knowledge = self._structure_knowledge(analyzed_knowledge)
            
            # 3. Í∑úÏπô ÏÉùÏÑ±
            knowledge_rules = self._generate_knowledge_rules(structured_knowledge)
            
            # 4. Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú
            validated_knowledge = self._validate_and_refine_knowledge(knowledge_rules)
            
            self.explicit_knowledge = validated_knowledge
            print("‚úÖ ÏïîÎ¨µÏ†Å ÏßÄÏãù ‚Üí Î™ÖÏãúÏ†Å ÏßÄÏãù ÌôòÏÇ∞ ÏôÑÎ£å")
            
            return validated_knowledge
            
        except Exception as e:
            print(f"‚ùå ÏßÄÏãù ÌôòÏÇ∞ Ïò§Î•ò: {e}")
            return {}
    
    def _analyze_engineer_interviews(self, interviews: List[Dict]) -> Dict:
        """ÏóîÏßÄÎãàÏñ¥ Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        try:
            print("1Ô∏è‚É£ ÏóîÏßÄÎãàÏñ¥ Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù")
            
            analysis_results = {
                'sound_patterns': {},
                'diagnostic_criteria': {},
                'experience_rules': {},
                'heuristic_knowledge': {},
                'troubleshooting_flows': {}
            }
            
            for interview in interviews:
                # ÏÜåÎ¶¨ Ìå®ÌÑ¥ Î∂ÑÏÑù
                if 'sound_descriptions' in interview:
                    sound_patterns = self._extract_sound_patterns(interview['sound_descriptions'])
                    analysis_results['sound_patterns'].update(sound_patterns)
                
                # ÏßÑÎã® Í∏∞Ï§Ä Î∂ÑÏÑù
                if 'diagnostic_methods' in interview:
                    diagnostic_criteria = self._extract_diagnostic_criteria(interview['diagnostic_methods'])
                    analysis_results['diagnostic_criteria'].update(diagnostic_criteria)
                
                # Í≤ΩÌóò Í∑úÏπô Î∂ÑÏÑù
                if 'experience_stories' in interview:
                    experience_rules = self._extract_experience_rules(interview['experience_stories'])
                    analysis_results['experience_rules'].update(experience_rules)
                
                # Ìú¥Î¶¨Ïä§Ìã± ÏßÄÏãù Î∂ÑÏÑù
                if 'heuristic_tips' in interview:
                    heuristic_knowledge = self._extract_heuristic_knowledge(interview['heuristic_tips'])
                    analysis_results['heuristic_knowledge'].update(heuristic_knowledge)
                
                # Î¨∏Ï†ú Ìï¥Í≤∞ ÌùêÎ¶Ñ Î∂ÑÏÑù
                if 'troubleshooting_stories' in interview:
                    troubleshooting_flows = self._extract_troubleshooting_flows(interview['troubleshooting_stories'])
                    analysis_results['troubleshooting_flows'].update(troubleshooting_flows)
            
            print("‚úÖ Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏôÑÎ£å")
            return analysis_results
            
        except Exception as e:
            print(f"‚ö†Ô∏è Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return {}
    
    def _extract_sound_patterns(self, sound_descriptions: List[Dict]) -> Dict:
        """ÏÜåÎ¶¨ Ìå®ÌÑ¥ Ï∂îÏ∂ú"""
        patterns = {}
        
        for description in sound_descriptions:
            pattern_name = description.get('name', 'unknown')
            patterns[pattern_name] = {
                'description': description.get('description', ''),
                'frequency_characteristics': self._parse_frequency_description(description.get('frequency', '')),
                'amplitude_characteristics': self._parse_amplitude_description(description.get('amplitude', '')),
                'temporal_characteristics': self._parse_temporal_description(description.get('temporal', '')),
                'expert_notes': description.get('expert_notes', ''),
                'confidence_level': description.get('confidence', 0.8)
            }
        
        return patterns
    
    def _parse_frequency_description(self, freq_desc: str) -> Dict:
        """Ï£ºÌååÏàò ÏÑ§Î™Ö ÌååÏã±"""
        # "Ï†ÄÏ£ºÌåå", "Ï§ëÏ£ºÌåå", "Í≥†Ï£ºÌåå" Îì±ÏùÑ ÏàòÏπòÎ°ú Î≥ÄÌôò
        freq_ranges = {
            'Ï†ÄÏ£ºÌåå': (20, 200),
            'Ï§ëÏ£ºÌåå': (200, 1000),
            'Í≥†Ï£ºÌåå': (1000, 5000),
            'Ï¥àÍ≥†Ï£ºÌåå': (5000, 8000)
        }
        
        for key, value in freq_ranges.items():
            if key in freq_desc:
                return {'range': value, 'description': freq_desc}
        
        return {'range': (100, 1000), 'description': freq_desc}
    
    def _parse_amplitude_description(self, amp_desc: str) -> Dict:
        """ÏßÑÌè≠ ÏÑ§Î™Ö ÌååÏã±"""
        # "ÏïΩÌïú", "Ï§ëÍ∞Ñ", "Í∞ïÌïú" Îì±ÏùÑ ÏàòÏπòÎ°ú Î≥ÄÌôò
        amp_ranges = {
            'ÏïΩÌïú': (0.1, 0.3),
            'Ï§ëÍ∞Ñ': (0.3, 0.6),
            'Í∞ïÌïú': (0.6, 1.0)
        }
        
        for key, value in amp_ranges.items():
            if key in amp_desc:
                return {'range': value, 'description': amp_desc}
        
        return {'range': (0.2, 0.5), 'description': amp_desc}
    
    def _parse_temporal_description(self, temp_desc: str) -> Dict:
        """ÏãúÍ∞ÑÏ†Å ÌäπÏÑ± ÏÑ§Î™Ö ÌååÏã±"""
        # "ÏùºÏ†ïÌïú", "Î∂àÍ∑úÏπôÌïú", "Ï£ºÍ∏∞Ï†Å" Îì±ÏùÑ ÏàòÏπòÎ°ú Î≥ÄÌôò
        temporal_characteristics = {
            'ÏùºÏ†ïÌïú': {'regularity': 0.9, 'stability': 0.9},
            'Î∂àÍ∑úÏπôÌïú': {'regularity': 0.3, 'stability': 0.3},
            'Ï£ºÍ∏∞Ï†Å': {'regularity': 0.7, 'stability': 0.6},
            'ÏïàÏ†ïÏ†Å': {'regularity': 0.8, 'stability': 0.9},
            'Î∂àÏïàÏ†ïÌïú': {'regularity': 0.4, 'stability': 0.4}
        }
        
        for key, value in temporal_characteristics.items():
            if key in temp_desc:
                return {**value, 'description': temp_desc}
        
        return {'regularity': 0.5, 'stability': 0.5, 'description': temp_desc}
    
    def _extract_diagnostic_criteria(self, diagnostic_methods: List[Dict]) -> Dict:
        """ÏßÑÎã® Í∏∞Ï§Ä Ï∂îÏ∂ú"""
        criteria = {}
        
        for method in diagnostic_methods:
            method_name = method.get('name', 'unknown')
            criteria[method_name] = {
                'description': method.get('description', ''),
                'steps': method.get('steps', []),
                'thresholds': method.get('thresholds', {}),
                'decision_logic': method.get('decision_logic', ''),
                'confidence_factors': method.get('confidence_factors', {}),
                'expert_notes': method.get('expert_notes', '')
            }
        
        return criteria
    
    def _extract_experience_rules(self, experience_stories: List[Dict]) -> Dict:
        """Í≤ΩÌóò Í∑úÏπô Ï∂îÏ∂ú"""
        rules = {}
        
        for story in experience_stories:
            rule_name = story.get('situation', 'unknown')
            rules[rule_name] = {
                'context': story.get('context', ''),
                'symptoms': story.get('symptoms', []),
                'diagnosis': story.get('diagnosis', ''),
                'solution': story.get('solution', ''),
                'prevention': story.get('prevention', ''),
                'confidence': story.get('confidence', 0.7),
                'frequency': story.get('frequency', 'rare')  # rare, common, frequent
            }
        
        return rules
    
    def _extract_heuristic_knowledge(self, heuristic_tips: List[Dict]) -> Dict:
        """Ìú¥Î¶¨Ïä§Ìã± ÏßÄÏãù Ï∂îÏ∂ú"""
        heuristics = {}
        
        for tip in heuristic_tips:
            tip_name = tip.get('name', 'unknown')
            heuristics[tip_name] = {
                'rule': tip.get('rule', ''),
                'conditions': tip.get('conditions', []),
                'action': tip.get('action', ''),
                'confidence': tip.get('confidence', 0.8),
                'expert_notes': tip.get('expert_notes', ''),
                'applicability': tip.get('applicability', 'general')
            }
        
        return heuristics
    
    def _extract_troubleshooting_flows(self, troubleshooting_stories: List[Dict]) -> Dict:
        """Î¨∏Ï†ú Ìï¥Í≤∞ ÌùêÎ¶Ñ Ï∂îÏ∂ú"""
        flows = {}
        
        for story in troubleshooting_stories:
            flow_name = story.get('problem_type', 'unknown')
            flows[flow_name] = {
                'problem_description': story.get('problem_description', ''),
                'investigation_steps': story.get('investigation_steps', []),
                'decision_points': story.get('decision_points', []),
                'solution_paths': story.get('solution_paths', []),
                'success_criteria': story.get('success_criteria', []),
                'lessons_learned': story.get('lessons_learned', [])
            }
        
        return flows
    
    def _structure_knowledge(self, analyzed_knowledge: Dict) -> Dict:
        """ÏßÄÏãù Íµ¨Ï°∞Ìôî"""
        try:
            print("2Ô∏è‚É£ ÏßÄÏãù Íµ¨Ï°∞Ìôî")
            
            structured = {
                'knowledge_hierarchy': {
                    'level_1': 'sound_classification',
                    'level_2': 'diagnostic_methods',
                    'level_3': 'experience_rules',
                    'level_4': 'heuristic_tips',
                    'level_5': 'troubleshooting_flows'
                },
                'knowledge_relationships': self._build_knowledge_relationships(analyzed_knowledge),
                'confidence_mapping': self._build_confidence_mapping(analyzed_knowledge),
                'applicability_matrix': self._build_applicability_matrix(analyzed_knowledge)
            }
            
            print("‚úÖ ÏßÄÏãù Íµ¨Ï°∞Ìôî ÏôÑÎ£å")
            return structured
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÏßÄÏãù Íµ¨Ï°∞Ìôî Ïò§Î•ò: {e}")
            return {}
    
    def _build_knowledge_relationships(self, knowledge: Dict) -> Dict:
        """ÏßÄÏãù Í∞Ñ Í¥ÄÍ≥Ñ Íµ¨Ï∂ï"""
        relationships = {
            'sound_to_diagnosis': {},
            'diagnosis_to_solution': {},
            'experience_to_heuristic': {},
            'heuristic_to_troubleshooting': {}
        }
        
        # ÏÜåÎ¶¨ Ìå®ÌÑ¥ ‚Üí ÏßÑÎã® Î∞©Î≤ï Í¥ÄÍ≥Ñ
        for sound_name, sound_info in knowledge.get('sound_patterns', {}).items():
            relationships['sound_to_diagnosis'][sound_name] = []
            for diag_name, diag_info in knowledge.get('diagnostic_criteria', {}).items():
                if self._is_related(sound_info, diag_info):
                    relationships['sound_to_diagnosis'][sound_name].append(diag_name)
        
        return relationships
    
    def _is_related(self, sound_info: Dict, diag_info: Dict) -> bool:
        """ÏßÄÏãù Í∞Ñ Í¥ÄÎ†®ÏÑ± ÌåêÎã®"""
        # Í∞ÑÎã®Ìïú ÌÇ§ÏõåÎìú Îß§Ïπ≠ÏúºÎ°ú Í¥ÄÎ†®ÏÑ± ÌåêÎã®
        sound_desc = sound_info.get('description', '').lower()
        diag_desc = diag_info.get('description', '').lower()
        
        common_keywords = ['ÏßÑÎèô', 'ÏÜåÏùå', 'Ï£ºÌååÏàò', 'ÏßÑÌè≠', 'Ìå®ÌÑ¥']
        return any(keyword in sound_desc and keyword in diag_desc for keyword in common_keywords)
    
    def _build_confidence_mapping(self, knowledge: Dict) -> Dict:
        """Ïã†Î¢∞ÎèÑ Îß§Ìïë Íµ¨Ï∂ï"""
        confidence_map = {}
        
        for category, items in knowledge.items():
            confidence_map[category] = {}
            for item_name, item_info in items.items():
                confidence_map[category][item_name] = item_info.get('confidence', 0.5)
        
        return confidence_map
    
    def _build_applicability_matrix(self, knowledge: Dict) -> Dict:
        """Ï†ÅÏö© Í∞ÄÎä•ÏÑ± Îß§Ìä∏Î¶≠Ïä§ Íµ¨Ï∂ï"""
        applicability = {
            'general': [],
            'specific': [],
            'rare': [],
            'common': []
        }
        
        for category, items in knowledge.items():
            for item_name, item_info in items.items():
                freq = item_info.get('frequency', 'common')
                if freq in applicability:
                    applicability[freq].append(f"{category}.{item_name}")
        
        return applicability
    
    def _generate_knowledge_rules(self, structured_knowledge: Dict) -> Dict:
        """ÏßÄÏãù Í∑úÏπô ÏÉùÏÑ±"""
        try:
            print("3Ô∏è‚É£ ÏßÄÏãù Í∑úÏπô ÏÉùÏÑ±")
            
            rules = {
                'if_then_rules': [],
                'fuzzy_rules': [],
                'probabilistic_rules': [],
                'temporal_rules': [],
                'contextual_rules': []
        }
        
        # IF-THEN Í∑úÏπô ÏÉùÏÑ±
        if_then_rules = self._generate_if_then_rules(structured_knowledge)
        rules['if_then_rules'] = if_then_rules
        
        # ÌçºÏßÄ Í∑úÏπô ÏÉùÏÑ±
        fuzzy_rules = self._generate_fuzzy_rules(structured_knowledge)
        rules['fuzzy_rules'] = fuzzy_rules
        
        # ÌôïÎ•†Ï†Å Í∑úÏπô ÏÉùÏÑ±
        prob_rules = self._generate_probabilistic_rules(structured_knowledge)
        rules['probabilistic_rules'] = prob_rules
        
        print("‚úÖ ÏßÄÏãù Í∑úÏπô ÏÉùÏÑ± ÏôÑÎ£å")
        return rules
        
        except Exception as e:
            print(f"‚ö†Ô∏è ÏßÄÏãù Í∑úÏπô ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return {}
    
    def _generate_if_then_rules(self, structured_knowledge: Dict) -> List[Dict]:
        """IF-THEN Í∑úÏπô ÏÉùÏÑ±"""
        rules = []
        
        # ÏòàÏãú Í∑úÏπôÎì§
        example_rules = [
            {
                'rule_id': 'R001',
                'description': 'Ï†ïÏÉÅ ÏïïÏ∂ïÍ∏∞ ÏÜåÎ¶¨ ÌåêÎã®',
                'if_conditions': [
                    'frequency_range == "Ï†ÄÏ£ºÌåå"',
                    'amplitude_range == "Ï§ëÍ∞Ñ"',
                    'regularity > 0.8',
                    'stability > 0.8'
                ],
                'then_action': 'classify_as_normal_compressor',
                'confidence': 0.9,
                'source': 'engineer_experience'
            },
            {
                'rule_id': 'R002',
                'description': 'Î≤†Ïñ¥ÎßÅ ÎßàÎ™® ÏÜåÎ¶¨ ÌåêÎã®',
                'if_conditions': [
                    'frequency_range == "Í≥†Ï£ºÌåå"',
                    'amplitude_range == "Í∞ïÌïú"',
                    'regularity < 0.5',
                    'stability < 0.5'
                ],
                'then_action': 'classify_as_bearing_wear',
                'confidence': 0.85,
                'source': 'engineer_experience'
            }
        ]
        
        rules.extend(example_rules)
        return rules
    
    def _generate_fuzzy_rules(self, structured_knowledge: Dict) -> List[Dict]:
        """ÌçºÏßÄ Í∑úÏπô ÏÉùÏÑ±"""
        rules = []
        
        # ÏòàÏãú ÌçºÏßÄ Í∑úÏπôÎì§
        example_fuzzy_rules = [
            {
                'rule_id': 'F001',
                'description': 'ÏÜåÏùå Î†àÎ≤® ÌçºÏßÄ ÌåêÎã®',
                'input_variables': {
                    'noise_level': {
                        'low': (0.0, 0.3),
                        'medium': (0.2, 0.7),
                        'high': (0.6, 1.0)
                    }
                },
                'output_variable': 'noise_severity',
                'rules': [
                    'IF noise_level IS low THEN noise_severity IS normal',
                    'IF noise_level IS medium THEN noise_severity IS warning',
                    'IF noise_level IS high THEN noise_severity IS critical'
                ],
                'confidence': 0.8
            }
        ]
        
        rules.extend(example_fuzzy_rules)
        return rules
    
    def _generate_probabilistic_rules(self, structured_knowledge: Dict) -> List[Dict]:
        """ÌôïÎ•†Ï†Å Í∑úÏπô ÏÉùÏÑ±"""
        rules = []
        
        # ÏòàÏãú ÌôïÎ•†Ï†Å Í∑úÏπôÎì§
        example_prob_rules = [
            {
                'rule_id': 'P001',
                'description': 'Î≤†Ïñ¥ÎßÅ ÎßàÎ™® ÌôïÎ•† Í≥ÑÏÇ∞',
                'conditions': {
                    'high_frequency_energy': 0.7,
                    'irregular_pattern': 0.8,
                    'increased_vibration': 0.6
                },
                'probabilities': {
                    'bearing_wear': 0.85,
                    'normal_wear': 0.10,
                    'other_issue': 0.05
                },
                'confidence': 0.8
            }
        ]
        
        rules.extend(example_prob_rules)
        return rules
    
    def _validate_and_refine_knowledge(self, knowledge_rules: Dict) -> Dict:
        """ÏßÄÏãù Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú"""
        try:
            print("4Ô∏è‚É£ ÏßÄÏãù Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú")
            
            validated = {
                'validated_rules': {},
                'confidence_scores': {},
                'consistency_check': {},
                'completeness_check': {},
                'refined_knowledge': {}
            }
            
            # Í∑úÏπô Í≤ÄÏ¶ù
            for rule_type, rules in knowledge_rules.items():
                validated['validated_rules'][rule_type] = []
                for rule in rules:
                    if self._validate_rule(rule):
                        validated['validated_rules'][rule_type].append(rule)
            
            # Ïã†Î¢∞ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞
            validated['confidence_scores'] = self._calculate_confidence_scores(validated['validated_rules'])
            
            # ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨
            validated['consistency_check'] = self._check_consistency(validated['validated_rules'])
            
            # ÏôÑÏ†ÑÏÑ± Í≤ÄÏÇ¨
            validated['completeness_check'] = self._check_completeness(validated['validated_rules'])
            
            print("‚úÖ ÏßÄÏãù Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú ÏôÑÎ£å")
            return validated
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÏßÄÏãù Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú Ïò§Î•ò: {e}")
            return {}
    
    def _validate_rule(self, rule: Dict) -> bool:
        """Í∞úÎ≥Ñ Í∑úÏπô Í≤ÄÏ¶ù"""
        required_fields = ['rule_id', 'description', 'confidence']
        return all(field in rule for field in required_fields) and rule['confidence'] > 0.5
    
    def _calculate_confidence_scores(self, validated_rules: Dict) -> Dict:
        """Ïã†Î¢∞ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞"""
        confidence_scores = {}
        
        for rule_type, rules in validated_rules.items():
            if rules:
                avg_confidence = sum(rule['confidence'] for rule in rules) / len(rules)
                confidence_scores[rule_type] = {
                    'average': avg_confidence,
                    'min': min(rule['confidence'] for rule in rules),
                    'max': max(rule['confidence'] for rule in rules),
                    'count': len(rules)
                }
        
        return confidence_scores
    
    def _check_consistency(self, validated_rules: Dict) -> Dict:
        """ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨"""
        consistency_issues = []
        
        # Í∑úÏπô Í∞Ñ Ï∂©Îèå Í≤ÄÏÇ¨
        for rule_type, rules in validated_rules.items():
            for i, rule1 in enumerate(rules):
                for j, rule2 in enumerate(rules[i+1:], i+1):
                    if self._rules_conflict(rule1, rule2):
                        consistency_issues.append({
                            'type': 'rule_conflict',
                            'rule1': rule1['rule_id'],
                            'rule2': rule2['rule_id'],
                            'severity': 'medium'
                        })
        
        return {
            'issues': consistency_issues,
            'consistency_score': max(0, 1.0 - len(consistency_issues) * 0.1)
        }
    
    def _rules_conflict(self, rule1: Dict, rule2: Dict) -> bool:
        """Í∑úÏπô Ï∂©Îèå Í≤ÄÏÇ¨"""
        # Í∞ÑÎã®Ìïú Ï∂©Îèå Í≤ÄÏÇ¨ (Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú Î°úÏßÅ ÌïÑÏöî)
        return (rule1.get('then_action') == rule2.get('then_action') and 
                rule1.get('confidence') > 0.8 and rule2.get('confidence') > 0.8)
    
    def _check_completeness(self, validated_rules: Dict) -> Dict:
        """ÏôÑÏ†ÑÏÑ± Í≤ÄÏÇ¨"""
        completeness_score = 0.0
        missing_areas = []
        
        # ÌïÑÏàò Í∑úÏπô ÏòÅÏó≠ Í≤ÄÏÇ¨
        required_areas = ['sound_classification', 'diagnostic_methods', 'troubleshooting']
        for area in required_areas:
            if not any(area in str(rules) for rules in validated_rules.values()):
                missing_areas.append(area)
        
        completeness_score = 1.0 - len(missing_areas) / len(required_areas)
        
        return {
            'completeness_score': completeness_score,
            'missing_areas': missing_areas,
            'recommendations': [f"Add rules for {area}" for area in missing_areas]
        }
    
    def create_synthetic_data_from_knowledge(self, explicit_knowledge: Dict) -> Dict:
        """Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°úÎ∂ÄÌÑ∞ Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        try:
            print("üéµ Î™ÖÏãúÏ†Å ÏßÄÏãù Í∏∞Î∞ò Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±")
            
            synthetic_data = {
                'audio_samples': {},
                'feature_vectors': {},
                'labels': {},
                'metadata': {}
            }
            
            # ÏßÄÏãù Í∏∞Î∞ò Ïò§ÎîîÏò§ ÏÉòÌîå ÏÉùÏÑ±
            for rule_type, rules in explicit_knowledge.get('validated_rules', {}).items():
                if rule_type == 'if_then_rules':
                    samples = self._generate_samples_from_if_then_rules(rules)
                    synthetic_data['audio_samples'][rule_type] = samples
                elif rule_type == 'fuzzy_rules':
                    samples = self._generate_samples_from_fuzzy_rules(rules)
                    synthetic_data['audio_samples'][rule_type] = samples
            
            # ÌäπÏßï Î≤°ÌÑ∞ ÏÉùÏÑ±
            synthetic_data['feature_vectors'] = self._generate_feature_vectors(synthetic_data['audio_samples'])
            
            # ÎùºÎ≤® ÏÉùÏÑ±
            synthetic_data['labels'] = self._generate_labels(synthetic_data['audio_samples'])
            
            # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            synthetic_data['metadata'] = {
                'generation_timestamp': datetime.now().isoformat(),
                'knowledge_source': 'engineer_explicit_knowledge',
                'total_samples': sum(len(samples) for samples in synthetic_data['audio_samples'].values()),
                'feature_count': 10
            }
            
            print("‚úÖ Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± ÏôÑÎ£å")
            return synthetic_data
            
        except Exception as e:
            print(f"‚ùå Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return {}
    
    def _generate_samples_from_if_then_rules(self, rules: List[Dict]) -> List[Dict]:
        """IF-THEN Í∑úÏπôÏúºÎ°úÎ∂ÄÌÑ∞ ÏÉòÌîå ÏÉùÏÑ±"""
        samples = []
        
        for rule in rules:
            if 'if_conditions' in rule:
                # Ï°∞Í±¥Ïóê ÎßûÎäî Ïò§ÎîîÏò§ ÏÉòÌîå ÏÉùÏÑ±
                sample = self._create_audio_sample_from_conditions(rule['if_conditions'])
                sample['rule_id'] = rule['rule_id']
                sample['confidence'] = rule['confidence']
                samples.append(sample)
        
        return samples
    
    def _create_audio_sample_from_conditions(self, conditions: List[str]) -> Dict:
        """Ï°∞Í±¥ÏúºÎ°úÎ∂ÄÌÑ∞ Ïò§ÎîîÏò§ ÏÉòÌîå ÏÉùÏÑ±"""
        # Ï°∞Í±¥ÏùÑ ÌååÏã±ÌïòÏó¨ Ïò§ÎîîÏò§ ÌååÎùºÎØ∏ÌÑ∞ ÏÉùÏÑ±
        audio_params = {
            'frequency': 1000,  # Í∏∞Î≥∏Í∞í
            'amplitude': 0.5,   # Í∏∞Î≥∏Í∞í
            'duration': 5.0,    # 5Ï¥à
            'sample_rate': 16000
        }
        
        for condition in conditions:
            if 'frequency_range' in condition:
                if 'Ï†ÄÏ£ºÌåå' in condition:
                    audio_params['frequency'] = np.random.uniform(60, 200)
                elif 'Í≥†Ï£ºÌåå' in condition:
                    audio_params['frequency'] = np.random.uniform(2000, 5000)
            elif 'amplitude_range' in condition:
                if 'Ï§ëÍ∞Ñ' in condition:
                    audio_params['amplitude'] = np.random.uniform(0.3, 0.6)
                elif 'Í∞ïÌïú' in condition:
                    audio_params['amplitude'] = np.random.uniform(0.6, 1.0)
        
        # Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        t = np.linspace(0, audio_params['duration'], int(audio_params['sample_rate'] * audio_params['duration']))
        audio_data = audio_params['amplitude'] * np.sin(2 * np.pi * audio_params['frequency'] * t)
        
        return {
            'audio_data': audio_data,
            'parameters': audio_params,
            'sample_rate': audio_params['sample_rate']
        }
    
    def _generate_samples_from_fuzzy_rules(self, rules: List[Dict]) -> List[Dict]:
        """ÌçºÏßÄ Í∑úÏπôÏúºÎ°úÎ∂ÄÌÑ∞ ÏÉòÌîå ÏÉùÏÑ±"""
        samples = []
        
        for rule in rules:
            if 'input_variables' in rule:
                # ÌçºÏßÄ Î≥ÄÏàòÏóê Îî∞Î•∏ ÏÉòÌîå ÏÉùÏÑ±
                sample = self._create_audio_sample_from_fuzzy_variables(rule['input_variables'])
                sample['rule_id'] = rule['rule_id']
                sample['confidence'] = rule['confidence']
                samples.append(sample)
        
        return samples
    
    def _create_audio_sample_from_fuzzy_variables(self, variables: Dict) -> Dict:
        """ÌçºÏßÄ Î≥ÄÏàòÎ°úÎ∂ÄÌÑ∞ Ïò§ÎîîÏò§ ÏÉòÌîå ÏÉùÏÑ±"""
        audio_params = {
            'frequency': 1000,
            'amplitude': 0.5,
            'duration': 5.0,
            'sample_rate': 16000
        }
        
        # ÎÖ∏Ïù¥Ï¶à Î†àÎ≤®Ïóê Îî∞Î•∏ ÌååÎùºÎØ∏ÌÑ∞ Ï°∞Ï†ï
        if 'noise_level' in variables:
            noise_levels = variables['noise_level']
            if 'low' in noise_levels:
                audio_params['amplitude'] = np.random.uniform(0.1, 0.3)
            elif 'high' in noise_levels:
                audio_params['amplitude'] = np.random.uniform(0.7, 1.0)
        
        # Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        t = np.linspace(0, audio_params['duration'], int(audio_params['sample_rate'] * audio_params['duration']))
        audio_data = audio_params['amplitude'] * np.sin(2 * np.pi * audio_params['frequency'] * t)
        
        return {
            'audio_data': audio_data,
            'parameters': audio_params,
            'sample_rate': audio_params['sample_rate']
        }
    
    def _generate_feature_vectors(self, audio_samples: Dict) -> Dict:
        """ÌäπÏßï Î≤°ÌÑ∞ ÏÉùÏÑ±"""
        feature_vectors = {}
        
        for rule_type, samples in audio_samples.items():
            feature_vectors[rule_type] = []
            for sample in samples:
                # Í∞ÑÎã®Ìïú ÌäπÏßï Ï∂îÏ∂ú (Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú ÌäπÏßï Ï∂îÏ∂ú)
                features = self._extract_simple_features(sample['audio_data'])
                feature_vectors[rule_type].append(features)
        
        return feature_vectors
    
    def _extract_simple_features(self, audio_data: np.ndarray) -> np.ndarray:
        """Í∞ÑÎã®Ìïú ÌäπÏßï Ï∂îÏ∂ú"""
        features = [
            np.sqrt(np.mean(audio_data ** 2)),  # RMS
            np.mean(np.diff(np.sign(audio_data))),  # ZCR
            np.mean(audio_data),  # Mean
            np.std(audio_data),   # Std
            np.max(np.abs(audio_data)),  # Peak
            np.var(audio_data),   # Variance
            np.mean(np.abs(audio_data)),  # Mean absolute value
            np.median(audio_data),  # Median
            np.percentile(audio_data, 75) - np.percentile(audio_data, 25),  # IQR
            np.sum(audio_data > 0) / len(audio_data)  # Positive ratio
        ]
        
        return np.array(features)
    
    def _generate_labels(self, audio_samples: Dict) -> Dict:
        """ÎùºÎ≤® ÏÉùÏÑ±"""
        labels = {}
        
        for rule_type, samples in audio_samples.items():
            labels[rule_type] = []
            for sample in samples:
                # Í∑úÏπô IDÎ•º Í∏∞Î∞òÏúºÎ°ú ÎùºÎ≤® ÏÉùÏÑ±
                rule_id = sample.get('rule_id', 'unknown')
                label = {
                    'rule_id': rule_id,
                    'category': 'normal' if 'normal' in rule_id.lower() else 'abnormal',
                    'confidence': sample.get('confidence', 0.5)
                }
                labels[rule_type].append(label)
        
        return labels
    
    def save_explicit_knowledge(self, filepath: str = "data/explicit_knowledge.json"):
        """Î™ÖÏãúÏ†Å ÏßÄÏãù Ï†ÄÏû•"""
        try:
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(self.explicit_knowledge, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ Î™ÖÏãúÏ†Å ÏßÄÏãù Ï†ÄÏû• ÏôÑÎ£å: {filepath}")
            return True
            
        except Exception as e:
            print(f"‚ùå Î™ÖÏãúÏ†Å ÏßÄÏãù Ï†ÄÏû• Ïò§Î•ò: {e}")
            return False
    
    def print_knowledge_summary(self):
        """ÏßÄÏãù ÏöîÏïΩ Ï∂úÎ†•"""
        print("\n" + "=" * 60)
        print("üß† Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî Í≤∞Í≥º")
        print("=" * 60)
        
        if 'validated_rules' in self.explicit_knowledge:
            rules = self.explicit_knowledge['validated_rules']
            print(f"\nüìã Í≤ÄÏ¶ùÎêú Í∑úÏπô Ïàò:")
            for rule_type, rule_list in rules.items():
                print(f"   - {rule_type}: {len(rule_list)}Í∞ú")
        
        if 'confidence_scores' in self.explicit_knowledge:
            scores = self.explicit_knowledge['confidence_scores']
            print(f"\nüéØ Ïã†Î¢∞ÎèÑ Ï†êÏàò:")
            for rule_type, score_info in scores.items():
                print(f"   - {rule_type}: ÌèâÍ∑† {score_info['average']:.3f}")

# ÏÇ¨Ïö© ÏòàÏ†ú
if __name__ == "__main__":
    # Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏
    converter = KnowledgeExplicitConverter()
    
    print("üß† Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏")
    print("=" * 60)
    
    # Í∞ÄÏÉÅÏùò ÏóîÏßÄÎãàÏñ¥ Ïù∏ÌÑ∞Î∑∞ Îç∞Ïù¥ÌÑ∞
    sample_interviews = [
        {
            'sound_descriptions': [
                {
                    'name': 'Ï†ïÏÉÅ_ÏïïÏ∂ïÍ∏∞',
                    'description': 'ÏùºÏ†ïÌïú Ï†ÄÏ£ºÌåå ÏÜåÏùå',
                    'frequency': 'Ï†ÄÏ£ºÌåå',
                    'amplitude': 'Ï§ëÍ∞Ñ',
                    'temporal': 'ÏùºÏ†ïÌïú',
                    'expert_notes': 'Ï†ïÏÉÅÏ†ÅÏù∏ ÏïïÏ∂ïÍ∏∞ ÏûëÎèô ÏÜåÎ¶¨',
                    'confidence': 0.9
                },
                {
                    'name': 'Î≤†Ïñ¥ÎßÅ_ÎßàÎ™®',
                    'description': 'Î∂àÍ∑úÏπôÌïú Í≥†Ï£ºÌåå ÏßÑÎèô',
                    'frequency': 'Í≥†Ï£ºÌåå',
                    'amplitude': 'Í∞ïÌïú',
                    'temporal': 'Î∂àÍ∑úÏπôÌïú',
                    'expert_notes': 'Î≤†Ïñ¥ÎßÅ ÎßàÎ™®Î°ú Ïù∏Ìïú ÎßàÏ∞∞Ïùå',
                    'confidence': 0.85
                }
            ],
            'diagnostic_methods': [
                {
                    'name': 'ÏïàÏ†ïÏÑ±_Í≤ÄÏÇ¨',
                    'description': 'RMSÏôÄ ZCRÏùò Î≥ÄÎèôÍ≥ÑÏàò Í≥ÑÏÇ∞',
                    'steps': ['RMS Í≥ÑÏÇ∞', 'ZCR Í≥ÑÏÇ∞', 'Î≥ÄÎèôÍ≥ÑÏàò Í≥ÑÏÇ∞', 'ÏûÑÍ≥ÑÍ∞í ÎπÑÍµê'],
                    'thresholds': {'stability_threshold': 0.8},
                    'decision_logic': 'stability > 0.8Ïù¥Î©¥ Ï†ïÏÉÅ',
                    'confidence_factors': {'experience': 0.9, 'data_quality': 0.8},
                    'expert_notes': 'Í∞ÄÏû• Ï§ëÏöîÌïú ÏßÑÎã® Í∏∞Ï§Ä'
                }
            ],
            'experience_stories': [
                {
                    'situation': 'Î≤†Ïñ¥ÎßÅ_ÎßàÎ™®_Ï¥àÍ∏∞',
                    'context': 'ÏïïÏ∂ïÍ∏∞ Î≤†Ïñ¥ÎßÅ ÎßàÎ™® Ï¥àÍ∏∞ Îã®Í≥Ñ',
                    'symptoms': ['Í≥†Ï£ºÌåå ÏßÑÎèô', 'Î∂àÍ∑úÏπôÌïú ÏÜåÏùå', 'ÏßÑÎèô Ï¶ùÍ∞Ä'],
                    'diagnosis': 'Î≤†Ïñ¥ÎßÅ ÎßàÎ™®',
                    'solution': 'Î≤†Ïñ¥ÎßÅ ÍµêÏ≤¥',
                    'prevention': 'Ï†ïÍ∏∞ Ïú§Ìôú Î∞è Î™®ÎãàÌÑ∞ÎßÅ',
                    'confidence': 0.9,
                    'frequency': 'common'
                }
            ],
            'heuristic_tips': [
                {
                    'name': 'ÏÜåÏùå_Î†àÎ≤®_ÌåêÎã®',
                    'rule': 'ÏÜåÏùåÏù¥ Í∞ëÏûêÍ∏∞ Ï¶ùÍ∞ÄÌïòÎ©¥ Ïù¥ÏÉÅ ÏßïÌõÑ',
                    'conditions': ['ÏÜåÏùå Î†àÎ≤® Î≥ÄÌôî', 'ÏãúÍ∞ÑÏ†Å Î≥ÄÌôî'],
                    'action': 'Ï¶âÏãú Ï†êÍ≤Ä ÌïÑÏöî',
                    'confidence': 0.8,
                    'expert_notes': 'Í≤ΩÌóòÏÉÅ Í∞ÄÏû• Ìö®Í≥ºÏ†ÅÏù∏ Ìú¥Î¶¨Ïä§Ìã±',
                    'applicability': 'general'
                }
            ],
            'troubleshooting_stories': [
                {
                    'problem_type': 'ÏïïÏ∂ïÍ∏∞_Ïù¥ÏÉÅ',
                    'problem_description': 'ÏïïÏ∂ïÍ∏∞ÏóêÏÑú Ïù¥ÏÉÅ ÏÜåÏùå Î∞úÏÉù',
                    'investigation_steps': ['ÏÜåÏùå ÏúÑÏπò ÌôïÏù∏', 'Ï£ºÌååÏàò Î∂ÑÏÑù', 'ÏßÑÎèô Ï∏°Ï†ï'],
                    'decision_points': ['Ï†ïÏÉÅ Î≤îÏúÑ ÎÇ¥?', 'Ï†êÏßÑÏ†Å Î≥ÄÌôî?', 'Í∏âÍ≤©Ìïú Î≥ÄÌôî?'],
                    'solution_paths': ['Ï†ïÍ∏∞ Ï†êÍ≤Ä', 'Î∂ÄÌíà ÍµêÏ≤¥', 'Ï†ÑÏ≤¥ ÍµêÏ≤¥'],
                    'success_criteria': ['ÏÜåÏùå Í∞êÏÜå', 'ÏßÑÎèô Ï†ïÏÉÅÌôî', 'ÏÑ±Îä• ÌöåÎ≥µ'],
                    'lessons_learned': ['Ï°∞Í∏∞ Î∞úÍ≤¨ Ï§ëÏöî', 'Ï†ïÍ∏∞ Î™®ÎãàÌÑ∞ÎßÅ ÌïÑÏöî']
                }
            ]
        }
    ]
    
    # ÏïîÎ¨µÏ†Å ÏßÄÏãùÏùÑ Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°ú ÌôòÏÇ∞
    explicit_knowledge = converter.convert_implicit_to_explicit_knowledge(sample_interviews)
    
    # Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°úÎ∂ÄÌÑ∞ Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    synthetic_data = converter.create_synthetic_data_from_knowledge(explicit_knowledge)
    
    # ÏßÄÏãù ÏöîÏïΩ Ï∂úÎ†•
    converter.print_knowledge_summary()
    
    # Î™ÖÏãúÏ†Å ÏßÄÏãù Ï†ÄÏû•
    converter.save_explicit_knowledge()
    
    print("\nüéâ Í∏∞Í≥Ñ ÏóîÏßÄÎãàÏñ¥ ÏßÄÏãù Î™ÖÏãúÌôî ÏôÑÎ£å!")
    print("   ÏïîÎ¨µÏ†Å ÏßÄÏãùÏù¥ Î™ÖÏãúÏ†Å ÏßÄÏãùÏúºÎ°ú ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌôòÏÇ∞ÎêòÏóàÏäµÎãàÎã§.")
