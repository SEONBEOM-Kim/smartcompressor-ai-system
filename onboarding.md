@gmdnq2tp 
주영님 온보딩 플랜
1단계: 분석 및 진단 (Analysis & Diagnosis) - 첫 1주
목표: 현재 시스템의 건강 상태를 정확히 진단하고, 잠재적 위험 요소를 모두 파악한다. (주영님이 이미 피그마로 시작하신 작업의 심화 과정입니다.)
[Action Item 1] 전체 아키텍처 맵핑: 현재 피그마 작업을 확장하여, ESP32 펌웨어 → Flask 서버 (app.py) → 라우트 (esp32_routes.py) → 데이터 저장소 → AI 분석 모듈 (ai_service.py)까지 데이터가 흐르는 전체 경로를 완벽하게 문서화합니다.
[Action Item 2] 병목 현상(Bottleneck) 식별: "만약 15개의 센서가 5초마다 동시에 오디오 파일을 업로드한다면, 우리 시스템의 어느 부분이 가장 먼저 무너질까?" 라는 질문에 답을 찾아야 합니다. (예: 단일 프로세스로 동작하는 Flask 서버, 파일 I/O, DB 커넥션 등)
F/E 안정화 : 고객이 우리 첫 페이지를 보고 시그널크래프트가 무엇을 하는 회사인지 빠르게 파악하고 구매 직전까지 이어지는 플로우로 유도해야 한다.
2단계: 안정화 및 최적화 (Stabilization & Optimization) - 2주 ~ 3주
목표: 진단된 문제점 중, 서비스 안정성에 가장 치명적인 것부터 해결하여 '최소 상용화 기준'을 달성한다.
[Action Item 1] 부하 테스트(Load Testing) 환경 구축: 15개의 가상 센서가 동시에 데이터를 보내는 간단한 테스트 스크립트를 작성하고 실행하여, 1단계에서 예측한 병목 현상이 실제로 발생하는지 데이터로 증명합니다.
[Action Item 2] Production-Grade 서버 도입: 현재의 Flask 개발 서버를 Gunicorn이나 uWSGI 같은 프로덕션용 WSGI 서버로 교체하고, Nginx를 앞단에 두어 리버스 프록시로 사용하도록 아키텍처를 개선합니다. 이것만으로도 동시 접속 처리 능력이 수십 배 향상됩니다.
[Action Item 3] 비동기 처리 도입 검토: 오디오 파일 업로드와 같이 시간이 오래 걸리는 작업을 처리하기 위해, Celery나 Redis Queue 같은 비동기 태스크 큐 도입을 검토하고, 최소 기능으로 구현합니다.
3단계: 모니터링 및 자동화 (Monitoring & Automation) - 4주차
목표: 문제가 발생했을 때 우리가 고객보다 먼저 알 수 있는 시스템을 구축하고, 반복적인 배포 작업을 자동화한다.
[Action Item 1] 기본 모니터링 시스템 구축: Sentry 같은 무료 에러 트래킹 툴을 연동하여 코드에서 발생하는 에러를 실시간으로 수집하고, 서버의 CPU/메모리 사용량을 확인할 수 있는 기본 대시보드를 구축합니다.
[Action 'Item 2] 배포 자동화(CI/CD) 파이프라인 구축: GitHub Actions를 활용하여, main 브랜치에 코드가 푸시(push)되면 자동으로 서버에 배포되도록 기본적인 CI/CD 파이프라인을 구축합니다.