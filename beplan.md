🚀 SignalCraft 백엔드 아키텍처 및 개발 히스토리 종합 보고서문서 목표: SignalCraft 프로젝트의 시작부터 현재까지의 모든 백엔드 개발 과정, 인프라 구축, 시행착오 및 해결 기록을 체계적으로 정리한다. 이를 통해 현재 아키텍처를 명확히 이해하고, 미래의 기술적 방향성과 확장 계획을 위한 확고한 기반을 마련한다.문서 최종 업데이트: 2025년 10월 16일1. 프로젝트의 시작: 듀얼 백엔드와 로컬 환경프로젝트는 초기에 Node.js(Express)와 Python(Flask)을 동시에 사용하는 듀얼 백엔드 아키텍처로 설계되었다. 각 서버는 아래와 같은 명확한 역할 분담을 가지고 있었다.Node.js (Express): 인증, 실시간 알림(SSE) 등 I/O 집약적 작업Python (Flask): AI/ML 분석, IoT 센서 데이터 처리 등 CPU 집약적 작업데이터베이스: SQLite를 사용하여 로컬 파일 시스템에 데이터를 저장이 구조는 각 언어의 장점을 활용한 영리한 설계였으나, 실제 서비스 운영 및 확장을 고려했을 때 다음과 같은 명확한 한계점을 가지고 있었다.확장성 부재: 단일 서버 인스턴스에 모든 기능이 집중되어 트래픽 증가 시 병목 현상 발생데이터베이스 동시성 문제: 파일 기반의 SQLite는 여러 사용자가 동시에 데이터를 쓰려고 할 때 성능이 저하되거나 잠금(Lock) 문제가 발생할 수 있음불안정한 운영: PM2와 같은 프로세스 관리 도구가 일부만 적용되어 있었고, 체계적인 배포 및 서버 관리 시스템이 부재했음이러한 한계를 극복하고, 안정적이고 확장 가능한 상용 서비스를 구축하기 위해 클라우드 마이그레이션을 결정했다.2. 위대한 여정: AWS 클라우드로의 이전안정성과 확장성, 그리고 업계 표준을 고려하여 **Amazon Web Services(AWS)**를 클라우드 제공자로 선택하고, 서비스의 새로운 보금자리를 **서울 리전(ap-northeast-2)**에 구축했다.2.1. EC2: 우리의 새로운 서버인스턴스 생성: Ubuntu OS 기반의 EC2 인스턴스를 생성하여 웹 서버의 기반을 마련했다. 초기 설정은 VPN의 영향으로 미국 동부(us-east-1)에 생성되었으나, 국내 사용자의 접속 속도 및 규정 준수를 위해 서울 리전으로 이전하는 과정을 거쳤다.환경 구축: 서버에 접속하여 Git, Nginx, Node.js, Python, PM2 등 서비스 운영에 필요한 모든 소프트웨어를 설치하고, 애플리케이션 실행 환경을 완벽하게 구축했다.2.2. RDS: 우리의 새로운 중앙 데이터베이스엔진 선택: SQLite의 동시성 문제를 해결하고, 안정적인 데이터 관리를 위해 완전 관리형 서비스인 AWS RDS for PostgreSQL을 도입했다.보안 설계 (가장 중요):퍼블릭 액세스 비활성화: 데이터베이스를 외부 인터넷으로부터 완전히 격리하여 보안을 극대화했다.보안 그룹 설정: 오직 짝꿍인 EC2 인스턴스만이 데이터베이스의 5432 포트로 접근할 수 있도록 방화벽 규칙을 설정하여, 허가된 서버 외에는 누구도 데이터베이스에 접근할 수 없도록 설계했다.3. 시행착오의 기록: 문제 해결의 역사클라우드 인프라를 구축하고 애플리케이션을 연결하는 과정은 수많은 시행착오의 연속이었다. 이 기록은 미래에 동일한 문제를 겪지 않기 위한 귀중한 자산이다.3.1. 서버 접속 실패: "문이 열리지 않아요"문제 1: Connection timed out (시간 초과)원인: EC2의 '프라이빗 IP' 주소로 접속을 시도함. 이 주소는 AWS 내부망 전용 주소로, 외부 인터넷에서는 도달할 수 없다.해결: AWS 콘솔에서 **'퍼블릭 IPv4 주소'**를 확인하고, 이 주소로 접속하여 해결.문제 2: UNPROTECTED PRIVATE KEY FILE! (키 파일 권한 오류)원인: SSH 개인 키(.pem) 파일에 소유자 외 다른 사용자도 접근할 수 있는 '너무 열린' 권한이 설정되어 있어, 보안을 중시하는 SSH가 연결을 거부함.해결: Windows 파일 속성의 [보안] 탭에서, 현재 사용자 계정을 제외한 모든 사용자의 권한을 제거하여 해결.문제 3: Permission denied (publickey) (키 불일치)원인: EC2 인스턴스에 등록된 키 페어와 내 PC에서 사용하려는 .pem 파일이 서로 다른 짝이었음.해결: EC2 콘솔에서 정확한 **'키 페어 이름'**을 확인하고, 그에 맞는 올바른 .pem 파일을 사용하여 접속하여 해결.3.2. 데이터베이스 연결 실패: "집 안에 들어갈 수가 없어요"문제 1: timeout expired (로컬 PC -> AWS RDS 접속)원인: RDS의 '퍼블릭 액세스' 설정이 아니요로 되어 있어, 외부 인터넷(내 PC)에서의 접속 시도를 데이터베이스가 무시함. 또한, 보안 그룹에 내 PC의 IP 주소가 등록되어 있지 않았음.해결: RDS 설정을 수정하여 '퍼블릭 액세스'를 예로 변경하고, 보안 그룹 인바운드 규칙에 '내 IP'를 추가하여 해결.문제 2: password authentication failed (비밀번호 오류)원인: postgres(관리자) 계정과 jason(애플리케이션) 계정의 비밀번호를 혼동하여 사용함. 또는 설치/생성 시 비밀번호를 잘못 기억함.해결: pg_hba.conf 파일을 수정하는 '응급 복구' 절차를 통해 postgres 관리자 비밀번호를 강제로 재설정하고, 이를 통해 jason 사용자의 비밀번호도 ALTER USER 명령어로 확실하게 재설정하여 해결.문제 3: public 스키마 접근 권한 없음 (권한 부족)원인: jason 사용자가 signalcraft 데이터베이스에 접속할 권한은 있었지만, 그 안에서 테이블을 생성하는 등 무언가를 '만들' 권한은 없었음.해결: 데이터베이스의 소유권 자체를 jason에게 넘겨주는 ALTER DATABASE signalcraft OWNER TO jason; 명령어를 실행하여, jason 사용자가 해당 데이터베이스의 완전한 주인이 되도록 하여 해결.3.3. 애플리케이션 실행 오류: "코드가 이상해요"문제 1: dotenv 환경 변수 미적용원인: .env 파일을 읽는 require('dotenv').config() 코드가, 데이터베이스 연결을 시도하는 코드보다 나중에 실행되어, 애플리케이션이 localhost나 postgres 같은 기본값으로 연결을 시도함.해결: require('dotenv').config()를 애플리케이션 시작점(server.js)의 가장 최상단으로 이동시켜, 모든 코드보다 먼저 환경 변수를 로드하도록 수정하여 해결.문제 2: CREATE DATABASE in transaction block원인: pgAdmin에서 여러 SQL 문을 한 번에 실행할 때, CREATE DATABASE처럼 큰 작업은 다른 작업과 한 묶음(Transaction)으로 처리할 수 없다는 PostgreSQL의 규칙 위반.해결: CREATE DATABASE 문만 따로 먼저 실행하고, 나머지 CREATE USER, GRANT 문을 나중에 실행하여 해결.문제 3: duplicate key (중복 생성 오류)원인: 애플리케이션 초기화 로직이 여러 번 실행되면서, 이미 생성된 테이블이나 타입을 또 만들려고 시도함.해결: 모든 CREATE TABLE 구문을 **CREATE TABLE IF NOT EXISTS**로 수정하여, "만약 존재하지 않을 경우에만 만들어라"는 조건을 추가하여 해결.4. 현재 아키텍처 및 협업 워크플로우수많은 시행착오 끝에, 우리는 다음과 같은 안정적이고 전문적인 개발 및 배포 환경을 구축했다.4.1. 최종 아키텍처서버: 단일 EC2 인스턴스에서 PM2 클러스터 모드로 Node.js 앱 실행 (CPU 효율 극대화)데이터베이스: AWS RDS for PostgreSQL (안정적인 중앙 저장소)배포: GitHub Actions를 통한 CI/CD 파이프라인 구축 (main 브랜치 Push 시 자동 배포)4.2. Git 브랜치 및 협업 전략공식 저장소: kimjuyoung1127/smartcompressor-ai-system을 단일 공식 저장소(Single Source of Truth)로 지정.main 브랜치 보호: main 브랜치는 항상 배포 가능한 안정적인 상태로 유지하며, 직접적인 push를 금지한다.기능 브랜치(Feature Branch): 모든 개발 작업(프론트엔드, 백엔드)은 main에서 파생된 별도의 브랜치(예: feature/customer-dashboard)에서 진행한다.코드 리뷰 (Pull Request): 기능 개발이 완료되면, main 브랜치로 병합(Merge)을 요청하는 **Pull Request(PR)**를 생성한다.통합 및 배포: 팀원의 코드 리뷰 및 승인 후 PR을 Merge하면, GitHub Actions가 자동으로 실행되어 실제 서비스(signalcraft.kr)에 안전하게 배포된다.5. 미래를 향한 길: 서버 확장 전략현재 아키텍처는 초기 서비스 운영에 매우 적합하지만, 미래의 사용자 증가에 대비한 확장 계획을 미리 수립해야 한다.5.1. 잘못된 접근 방식: "프리티어 계정 여러 개 사용"내용: 여러 AWS 계정을 만들어 각각의 프리티어 서버를 인터넷을 통해 연결하는 방식.결론: AWS 약관 위반, 심각한 속도 저하, 관리 및 보안 문제로 인해 절대 사용해서는 안 되는 위험한 방식임을 확인했다.5.2. 올바른 단계별 확장 로드맵단계핵심 전략비유기대 효과적용 시점현재탄탄한 기반 확인레시피 표준화 완료확장 준비 완료완료Phase 1Redis 캐싱 도입인기 메뉴 키오스크 처리응답 속도 향상, DB 부하 감소단기 (즉시 권장)Phase 2스케일 업 (Scale-Up)주방을 더 큰 곳으로 이전즉각적인 서버 성능 향상중기 (서버가 느려질 때)Phase 3스케일 아웃 (Scale-Out)자동화된 주방 증설 시스템대규모 트래픽 처리, 비용 최적화장기 (본격 성장 시)단기 최우선 과제: 사용자의 로그인 정보(세션) 등 자주 조회되는 데이터를 AWS ElastiCache for Redis와 같은 인메모리 캐시에 저장하여, DB의 부하를 줄이고 사용자 경험을 극적으로 향상시키는 것이다.장기 목표: 최종적으로는 **Application Load Balancer(ALB)와 Auto Scaling Group(ASG)**을 도입하여, 트래픽에 따라 서버 수를 자동으로 조절하는 진정한 수평 확장을 구현한다.결론적으로, SignalCraft 프로젝트는 로컬 개발 환경의 한계를 넘어, AWS 클라우드 위에서 체계적인 협업 방식과 자동화된 배포 시스템을 갖춘, 확장 가능한 서비스로 성공적으로 전환되었다. 이 보고서에 기록된 모든 경험은 앞으로 프로젝트를 더욱 발전시켜 나가는 데 있어 귀중한 자산이 될 것이다.